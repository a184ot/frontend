## Материалы для изучения

[70 лучших вопросов и ответов на собеседовании по React JS](https://career.guru99.com/ru/reactjs-interview-questions/)

[Вопросы к собеседованию React (Junior level)](https://habr.com/ru/articles/803799/)

[Вопросы на собеседовании фронтенд разработчика React.js](https://github.com/evgenii-studitskikh/react-ru-interview-questions)

[45 вопросов для подготовки к собеседованию по React](https://proglib.io/p/45-voprosov-dlya-podgotovki-k-sobesedovaniyu-po-react-2023-11-27)

[Лучшие практики применения принципов SOLID в React](https://proglib.io/p/luchshie-praktiki-primeneniya-principov-solid-v-react-2022-08-10)

[Паттерны проектирования для фронтенда и пицца — что общего? Разбираем на понятных примерах](https://highload.today/blogs/patterny-proektirovaniya-dlya-frontenda-i-pitstsa-chto-obshhego-razbiraem-na-ponyatnyh-primerah/)

[Design Patterns: прототип, прокси и обозреватель для фронтенд-разработчика](https://habr.com/ru/articles/754444/)

[Архитектура фронтенда и какой она должна быть](https://habr.com/ru/articles/667214/)

[Архитектура front-end приложений — react, react native, angular](https://habr.com/ru/articles/726354/)



##  Junior / Middle interview (gpt)

<details>
  <summary>1. JavaScript (JS) Вопросы</summary>

**Вопрос**: Что такое “use strict” и зачем он нужен? **Ответ**: “use strict” активирует строгий режим в JavaScript. Он запрещает некоторые «небезопасные» особенности языка (например, неявное создание глобальных переменных), помогает избежать ошибок и улучшает оптимизацию кода движком JS.

**Вопрос**: В чём разница между let, var и const? **Ответ**: var — функциональная область видимости, поднятие (hoisting). let и const — блочная область видимости, без поднятия в классическом понимании. const нельзя переопределить, но можно мутировать объект.

**Вопрос**: Что такое замыкание (closure) в JavaScript? **Ответ**: Замыкание — это функция, которая запоминает своё лексическое окружение (переменные, доступные на момент создания), даже когда она вызывается вне своей области видимости.

**Вопрос**: Как работает каррирование (currying) в JavaScript? **Ответ**: Каррирование — это преобразование функции с множеством аргументов в набор вложенных функций, каждая из которых принимает по одному аргументу и в итоге возвращает результат.

**Вопрос**: Что делает оператор new? **Ответ**: Создаёт новый объект, устанавливает прототип объекта в prototype конструктора, вызывает конструктор в контексте нового объекта, а затем возвращает объект.

**Вопрос**: Как проверить, является ли значение массивом? **Ответ**: Использовать Array.isArray(value) или value instanceof Array.

**Вопрос**: В чём разница между оператором == и ===? **Ответ**: == выполняет приведение типов перед сравнением, === сравнивает без преобразования типов (строгое сравнение).

**Вопрос**: Что такое hoisting в JavaScript? **Ответ**: Механизм поднятия объявлений переменных и функций в начало области видимости. Переменные var и функции доступны до точки фактического объявления (хотя переменные будут со значением undefined).

**Вопрос**: Как работают стрелочные функции (=>)? **Ответ**: Стрелочные функции не имеют собственного this, берут его из внешней области видимости, а также у них нет arguments. Их синтаксис короче по сравнению с обычными функциями.

**Вопрос**: Что такое IIFE? **Ответ**: IIFE (Immediately Invoked Function Expression) — функция, которая объявляется и вызывается немедленно. Используется для создания локальной области видимости и предотвращения утечек в глобальную область.

**Вопрос**: Как можно скопировать объект в JavaScript? **Ответ**: Поверхностно: Object.assign({}, obj) или спред-оператор {...obj}. Глубокое копирование требует либо рекурсивного обхода, либо JSON-подход JSON.parse(JSON.stringify(obj)), либо специализированные утилиты.

**Вопрос**: Что такое всплытие (bubbling) и перехват (capturing) событий? **Ответ**: Всплытие — событие сначала обрабатывается на самом глубоком элементе, а потом поднимается вверх по DOM. Перехват — событие идёт сверху вниз. По умолчанию используется всплытие.

**Вопрос**: Для чего используется оператор “spread” (...)? **Ответ**: Оператор spread позволяет расширять массивы и объекты в местах, где ожидаются списки значений или ключей, а также используется для поверхностного копирования или объединения объектов/массивов.

**Вопрос**: Чем отличается стрелочная функция от обычной функции с точки зрения this? **Ответ**: В стрелочной функции this берётся из лексического окружения (родительской области), а в обычных функциях this определяется в момент вызова.

**Вопрос**: В чём разница между методами массива map и forEach? **Ответ**: map возвращает новый массив, трансформируя каждый элемент, а forEach просто выполняет функцию для каждого элемента без возврата нового массива.

**Вопрос**: Как работает цикл for...in и for...of? **Ответ**: for...in итерирует по именам (ключам) свойств объекта или индексов массива. for...of итерирует по значениям и работает с итерируемыми объектами, например массивами или строками.

**Вопрос**: Что такое «порождающие функции» (Generators) в JavaScript? **Ответ**: Generators — функции, которые могут приостанавливать и возобновлять выполнение, используя ключевое слово yield. Обозначаются function*.

**Вопрос**: Чем отличаются undefined и null? **Ответ**: undefined означает, что переменной не присвоено значение или она не определена вовсе. null — это намеренное «пустое» значение.

**Вопрос**: Как работает оператор “?” (тернарный оператор)? **Ответ**: условие ? выражениеЕслиИстина : выражениеЕслиЛожь. Если условие истинно, возвращается первое выражение, иначе — второе.

**Вопрос**: Что такое Polyfill? **Ответ**: Polyfill — это скрипт, который эмулирует поддержку функций языка, отсутствующих в некоторых старых браузерах (например, Promise, fetch и т.д.).

**Вопрос**: Зачем использовать метод bind? **Ответ**: bind создаёт новую функцию с привязанным контекстом this и (опционально) частично применёнными аргументами.

**Вопрос**: Что делает метод call и чем отличается от apply? **Ответ**: call вызывает функцию с заданным this и аргументами, передаваемыми отдельно. apply делает то же самое, но аргументы передаются массивом.

**Вопрос**: Чем отличается «тень прототипа» (shadowing) от унаследованного свойства? **Ответ**: Если свойство с тем же именем определено на самом объекте, оно «затеняет» унаследованное из prototype. При доступе к свойству видится собственное, а не прототипное.

**Вопрос**: Как проверить, является ли объект «пустым» (не содержит собственных свойств)? **Ответ**: Можно получить массив ключей Object.keys(obj) и проверить длину 0, то же с Object.entries(obj).

**Вопрос**: Что такое BigInt? **Ответ**: BigInt — специальный числовой тип, позволяющий работать с целыми числами произвольной длины (больше чем Number.MAX_SAFE_INTEGER), обозначаются добавлением n в конце числа.

**Вопрос**: Как работает деструктуризация (destructuring)? **Ответ**: Деструктуризация позволяет извлекать значения из объектов и массивов по ключам/индексам, например:

`const {a, b} = obj;`

`const [x, y] = arr;`

**Вопрос**: Что такое “NaN”? Когда он может появиться? **Ответ**: “NaN” (Not a Number) — специальное значение, указывающее на некорректную математическую операцию. Например parseInt('abc'), 0/0 и т.д.

**Вопрос**: Как в JavaScript выполнить «дебианст» (debounce) или «троттлинг» (throttle) функции? **Ответ**: Обычно используют вспомогательные функции (например, из lodash: _.debounce, _.throttle). «Debounce» откладывает вызов пока не пройдёт определённое время молчания, «Throttle» ограничивает количество вызовов за определённый промежуток.

**Вопрос**: Что такое Event Loop и как он работает? **Ответ**: Event Loop — это механизм JS, который управляет очередью коллбэков. Он обрабатывает задачу из очереди, выполняет её, затем берёт следующую и т.д., позволяя JS быть асинхронным по одной нити.

**Вопрос**: Чем отличается синхронный код от асинхронного? **Ответ**: Синхронный код выполняется последовательно (каждая операция блокирует следующую). Асинхронный позволяет не дожидаться завершения операции (например, сетевой запрос), а продолжить выполнение и обработать результат по завершении.

**Вопрос**: Что такое “Promise” в JavaScript? **Ответ**: Объект, представляющий отложенное и потенциально успешное или неуспешное вычисление. Имеет методы then, catch, finally.

**Вопрос**: Как работает async/await? **Ответ**: async помечает функцию как асинхронную, что позволяет использовать await внутри. await «приостанавливает» выполнение функции до получения результата промиса.

**Вопрос**: Как правильно обрабатывать ошибки в async/await? **Ответ**: Обернуть в try...catch или использовать .catch() у возвращаемого промиса. Пример:

`try {`

`const data = await fetchData();`

`} catch (err) {`

`console.error(err);`

`}`

**Вопрос**: Что такое fetch и чем он отличается от XMLHttpRequest? **Ответ**: fetch — современный API для HTTP-запросов. Работает на промисах, имеет более удобный синтаксис. XMLHttpRequest — старый способ, с коллбэками.

**Вопрос**: В чём разница между микрозадачами (microtasks) и макрозадачами (macrotasks)? **Ответ**: Микрозадачи (например, промисы) имеют приоритет и выполняются после текущего стека синхронных операций и перед макрозадачами (например, события таймера). Макрозадачи ставятся в очередь события.

**Вопрос**: Можно ли переопределить неизменяемый глобальный объект, например window? **Ответ**: Нельзя напрямую переопределить системный объект, но можно добавлять или изменять свойства, если это разрешено движком JS. Полностью перезаписать объект window невозможно.

**Вопрос**: Как работает оператор «?» при доступе к свойствам (Optional Chaining)? **Ответ**: obj?.prop позволяет не выбрасывать ошибку, если obj равен null или undefined. Возвращает undefined вместо ошибки.

**Вопрос**: Что такое символы (Symbol) в JavaScript? **Ответ**: Это уникальные и неизменяемые идентификаторы, которые можно использовать в качестве ключей объекта, чтобы избежать конфликтов имён.

**Вопрос**: Что делает метод массива reduce? **Ответ**: Применяет коллбэк к каждому элементу, аккумулируя результат в одном значении, которое и возвращается.

**Вопрос**: Как проверить, что число является целым? **Ответ**: Использовать Number.isInteger(value).

</details>

<details>
  <summary>2. React Вопросы</summary>

**Вопрос**: Что такое React и в чём его основная идея? **Ответ**: React — библиотека для построения пользовательских интерфейсов. Основная идея — компонентный подход и обновление DOM с помощью Virtual DOM для высокой производительности.

**Вопрос**: Что такое Virtual DOM? **Ответ**: Это виртуальное представление реального DOM-дерева в памяти. React сравнивает Virtual DOM с предыдущим состоянием (diffing) и обновляет только изменившиеся части в реальном DOM.

**Вопрос**: Как создаются компоненты в React? **Ответ**: Компоненты могут быть функциональными (function components) или классовыми (class components), возвращают JSX для рендеринга.

**Вопрос**: Что такое JSX? **Ответ**: JSX — синтаксическое расширение JavaScript, которое выглядит как HTML в JS, но под капотом компилируется в вызовы React.createElement.

**Вопрос**: Чем отличается контролируемый компонент (controlled component) от неконтролируемого (uncontrolled)? **Ответ**: В контролируемом компоненте значение формы хранится в стейте React и обновляется через onChange. В неконтролируемом — значение хранится в DOM, управляется самим элементом.

**Вопрос**: Как работает setState в классовых компонентах? **Ответ**: setState асинхронно обновляет состояние и вызывает повторный рендер. Можно использовать коллбэк setState(updater, callback) для получения актуального стейта.

**Вопрос**: Что такое «ключи» (keys) в React и зачем они нужны? **Ответ**: Ключи нужны для идентификации элементов в списке. Помогают React правильно сопоставлять элементы при рендере (diffing), чтобы не перерисовывать всё заново.

**Вопрос**: Какие есть методы жизненного цикла (lifecycle) в классовых компонентах? **Ответ**: Основные: constructor, componentDidMount, componentDidUpdate, componentWillUnmount, а также shouldComponentUpdate, componentDidCatch и т.д. С React 16 некоторые методы устарели (componentWillMount и др.).

**Вопрос**: Что такое HOC (Higher-Order Component)? **Ответ**: HOC — это функция, которая принимает компонент и возвращает новый компонент, дополняя его дополнительной функциональностью (пример: connect из react-redux).

**Вопрос**: Как работают фрагменты (React.Fragment)? **Ответ**: Позволяют группировать список дочерних элементов без добавления лишнего узла в DOM. Запись: <>children</> или <React.Fragment>children</React.Fragment>.

**Вопрос**: Что такое Portals в React? **Ответ**: Portals позволяют рендерить дочерние элементы в DOM-узел, который находится вне иерархии основного компонента (например, модальные окна).

**Вопрос**: Как обрабатывать ошибки в React-компонентах? **Ответ**: Использовать компоненты-обработчики ошибок (Error Boundaries). Они ловят ошибки в методе componentDidCatch и отображают запасной UI.

**Вопрос**: Что такое «Children» в React? **Ответ**: props.children — специальный проп, содержащий всё, что передано между открывающим и закрывающим тегами компонента.

**Вопрос**: Когда нужно использовать «PureComponent»? **Ответ**: React.PureComponent автоматически реализует shouldComponentUpdate с поверхностным сравнением пропов и стейта. Полезно для повышения производительности, если пропы простые.

**Вопрос**: Как работает useState? **Ответ**: Хук useState возвращает текущее значение состояния и функцию для его обновления. При вызове функции обновления React запускает повторный рендер компонента.

**Вопрос**: Как работает useEffect? **Ответ**: Хук, который выполняет побочные эффекты (запросы к API, подписки). Можно контролировать, когда хук срабатывает, через массив зависимостей.

**Вопрос**: Что делает useMemo? **Ответ**: Мемоизирует результат вычисления функции и повторно вычисляет только при изменении зависимостей, тем самым оптимизируя производительность.

**Вопрос**: Для чего нужен useCallback? **Ответ**: Возвращает мемоизированный коллбэк, который пересоздаётся только при изменении указанных зависимостей. Это помогает избежать лишних ререндеров при передаче коллбэков в дочерние компоненты.

**Вопрос**: Что такое useReducer? **Ответ**: Хук, аналогичный Redux reducer внутри функционального компонента. Позволяет управлять сложным состоянием через редьюсеры.

**Вопрос**: Как работать с контекстом (Context API) в React? **Ответ**: Создать контекст через React.createContext, использовать Provider для передачи значения и useContext (или Consumer) для получения значения в компонентах.

**Вопрос**: Можно ли вызывать хуки в циклах и условных операторах? **Ответ**: Нет. Хуки должны вызываться на верхнем уровне компонента, в одном и том же порядке при каждом рендере.

**Вопрос**: Как React сравнивает элементы при рендеринге (reconciliation)? **Ответ**: React использует алгоритм сопоставления (diffing), который сравнивает Virtual DOM с предыдущей версией. Если тип элемента тот же, выполняется сравнение атрибутов; иначе удаляется и создаётся заново.

**Вопрос**: Как передать пропы компоненту в React? **Ответ**: Через атрибуты в JSX, например: <MyComponent title="Hello" />. В функциональных компонентах доступ через параметры: function MyComponent({title}).

**Вопрос**: В чём разница между «контейнерными» и «презентационными» компонентами? **Ответ**: Презентационные (dumb) отвечают за отображение, не содержат бизнес-логики. Контейнерные (smart) работают со стейтом, логикой и обычно передают данные в презентационные компоненты.

**Вопрос**: Что такое «рефы» (refs) в React и для чего они нужны? **Ответ**: Refs дают доступ к DOM-узлам или элементам React. Используются для управления фокусом, выбора текста, измерения размера и т.д.

**Вопрос**: Что такое StrictMode в React? **Ответ**: Это инструмент для выявления потенциальных проблем в приложении, активирует дополнительные проверки и выводит предупреждения в консоль, но не меняет поведение в продакшне.

**Вопрос**: Какой «подход к стилям» предпочтительнее в React: CSS-модули, styled-components, inline-стили или что-то другое? **Ответ**: Зависит от проекта. CSS-модули и styled-components популярны благодаря изоляции стилей. Inline-стили обычно ограничены динамическими изменениями.

**Вопрос**: Как оптимизировать React-приложение? **Ответ**: Использовать мемоизацию (React.memo, useMemo, useCallback), разбивать код на динамические чанки (React.lazy), избегать лишних ререндеров, применять ключи для списков и т.д.

**Вопрос**: Что такое «серверный рендеринг» (SSR) и как он связан с React? **Ответ**: SSR — рендеринг React-компонентов на сервере, чтобы выдавать готовый HTML, что улучшает SEO и скорость первоначального отображения.

**Вопрос**: Как создаётся собственный хук? **Ответ**: Написать функцию с именем, начинающимся на use. Использовать внутри неё другие хуки React. Пример:

`function useMyHook() {`

`const [value, setValue] = useState(0);`

`// ...`

`return { value, setValue };`

`}`

</details>

<details>
  <summary>3. TypeScript (TS) Вопросы</summary>

**Вопрос**: Что такое TypeScript и в чём его основная цель? **Ответ**: TypeScript — надстройка над JavaScript, добавляющая статическую типизацию и некоторые возможности ООП. Цель — упростить разработку больших проектов и уменьшить количество ошибок.

**Вопрос**: Как объявить переменную с типом в TypeScript? **Ответ**:

`let age: number = 30;`

`const name: string = "Bob";`

**Вопрос**: Что такое Interface в TypeScript? **Ответ**: Interface — структура, описывающая форму объекта (какие поля и методы он содержит). Используется для типизации объектов и классов.

**Вопрос**: Как типизировать функцию в TypeScript? **Ответ**: Указать типы аргументов и тип возвращаемого значения:

`function add(a: number, b: number): number {`

`return a + b;`

`}`

**Вопрос**: Что такое «Union Types»? **Ответ**: Union Types позволяют переменной иметь несколько типов, например: let result: string | number;.

**Вопрос**: Что делает ключевое слово type? **Ответ**: type позволяет создавать псевдонимы типов (type aliases), которые можно использовать для более удобной записи:

`type ID = string | number;`

**Вопрос**: Как работает «Generics» в TypeScript? **Ответ**: Generics позволяют создавать обобщённый код (функции, классы и т.д.), который может работать с разными типами, сохраняя типобезопасность:

`function identity<T>(arg: T): T {`

`return arg;`

`}`

**Вопрос**: Что такое «Enums» в TypeScript? **Ответ**: Перечисления (Enums) позволяют создавать набор именованных констант. Например:

`enum Direction {`

`Up,`

`Down,`

`Left,`

`Right`

`}`

**Вопрос**: Что делает оператор as? **Ответ**: Оператор приведения типа (type assertion), говорит компилятору: «Доверься мне, я знаю тип лучше». Пример:

`let someValue: unknown = "hello";`

`(someValue as string).toUpperCase();`

**Вопрос**: Как описать тип для пропа компонента React? **Ответ**: Через интерфейс или тип:

`interface MyComponentProps {`

`title: string;`

`}`

`const MyComponent: React.FC<MyComponentProps> = ({ title }) => { ... }`

**Вопрос**: Что делать, если нужно описать тип с необязательным свойством? **Ответ**: Использовать знак «?»:

`interface User {`

`id: number;`

`name?: string;`

`}`

**Вопрос**: Что такое «Never» тип? **Ответ**: Тип never означает, что функция или выражение никогда не возвращают значение (например, выбрасывают ошибку) или бесконечный цикл.

**Вопрос**: Что такое «Unknown» тип? **Ответ**: unknown — более безопасная альтернатива any, когда тип заранее не известен. Обращаться к свойствам нельзя, пока не уточним тип.

**Вопрос**: Как ограничить доступ к свойствам класса в TypeScript? **Ответ**: Использовать модификаторы доступа public, protected, private, а также ключевое слово readonly для неизменяемых свойств.

**Вопрос**: Какие бывают конфигурации компилятора в TypeScript (tsconfig.json)? **Ответ**: Можно настроить target, module, strict, esModuleInterop, baseUrl, paths, outDir, rootDir и другие параметры.

**Вопрос**: В чём разница между «interface» и «type»? **Ответ**: В большинстве случаев их можно использовать аналогично. «interface» может расширяться (extends) и объединяться при повторном объявлении, а «type» — более гибок (может быть union и т.д.), но не объединяется при повторном объявлении.

**Вопрос**: Как типизировать React-хуки, например useState? **Ответ**: useState — дженерик, можно явно указать тип:

`const [count, setCount] = useState<number>(0);`

Вопрос: Что такое «declaration merging»? **Ответ**: Возможность объединять объявления интерфейсов с одинаковыми именами в один интерфейс. Это относится только к interface и namespace, но не к type.

**Вопрос**: Как описать «props.children» в TypeScript? **Ответ**:

`interface Props {`

`children: React.ReactNode;`

`}`

**Вопрос**: В чём разница между React.FC<Props> и обычным функциональным компонентом с типами? **Ответ**: React.FC автоматически добавляет тип для children, но может накладывать дополнительные ограничения (например, на типы defaultProps). Обычный подход через function MyComp(props: Props): JSX.Element.

</details>

<details>
  <summary>4. Redux Вопросы</summary>

**Вопрос**: Что такое Redux и для чего он нужен? **Ответ**: Redux — это библиотека для управления состоянием в приложении. Позволяет хранить и обновлять глобальное состояние в предсказуемом виде (через actions и reducers).

**Вопрос**: Что такое «Store» в Redux? **Ответ**: Центральное хранилище (store), содержащее состояние приложения. В нём вызываются редьюсеры, и к нему подключаются компоненты через react-redux.

**Вопрос**: Что такое «Action» и «Action Creator» в Redux? **Ответ**: Action — это объект с обязательным полем type, описывает, что произошло. Action Creator — функция, которая возвращает action для удобства и исключения ошибок при наборе type.

**Вопрос**: Что делает «Reducer» в Redux? **Ответ**: Функция (state, action) => newState. Она получает текущее состояние и экшен и возвращает новое состояние, не мутируя старое.

**Вопрос**: Как Redux обрабатывает асинхронные действия? **Ответ**: По умолчанию никак. Используются middleware (например, redux-thunk или redux-saga) для обработки асинхронности, чтобы диспатчить actions по завершении.

**Вопрос**: Что такое Middleware в Redux? **Ответ**: Промежуточная функция, которая перехватывает actions до того, как они дойдут до редьюсера. Позволяет логировать, обрабатывать асинхронность, делать API-запросы и т.д.

**Вопрос**: Чем отличаются redux-thunk и redux-saga? **Ответ**: redux-thunk — позволяет диспатчить функции вместо экшенов и внутри выполнять асинхронный код. redux-saga — использует генераторы и работает как middleware, обрабатывая сайд-эффекты в более декларативном стиле.

**Вопрос**: В чём суть «immutability» в Redux? **Ответ**: Состояние должно быть неизменяемым (не мутируется). При обновлении создаётся копия объекта, что облегчает отслеживание изменений и отладку.

**Вопрос**: Как подключить Redux к React-приложению? **Ответ**: Установить react-redux, обернуть корневой компонент в <Provider store={store}>, а затем использовать useSelector и useDispatch или HOC connect.

**Вопрос**: Что делает метод combineReducers? **Ответ**: Объединяет несколько редьюсеров в один общий, где каждый редьюсер отвечает за свою ветку состояния.

**Вопрос**: Что такое «Selector» в Redux? **Ответ**: Функция, которая выбирает (извлекает) нужные данные из состояния (store). Помогает переиспользовать логику выборки и мемоизировать результаты (reselect).

**Вопрос**: Можно ли использовать React Context вместо Redux? **Ответ**: Да, для небольшого приложения можно. Но для сложного состояния Redux даёт лучшую структуру, инструменты отладки и тестируемость.

**Вопрос**: Что такое Redux DevTools? **Ответ**: Расширение для браузеров, позволяющее смотреть историю экшенов, текущее состояние, «перематывать» состояние, что упрощает отладку.

**Вопрос**: Как типизировать Redux Store и редьюсеры в TypeScript? **Ответ**: Использовать интерфейсы/типы для state и actions, создавать типы для редьюсеров, например:

`interface RootState {`

`user: UserState;`

`products: ProductsState;`

`}`

**Вопрос**: Что такое «Dispatch» и как с ним работать в TypeScript? **Ответ**: dispatch — функция в Redux store, принимающая экшен (или thunk). В TS можно создать типизированный AppDispatch и использовать его вместо любого Dispatch.

**Вопрос**: Зачем нужен compose в Redux? **Ответ**: compose — это функция для объединения нескольких функций справа налево, обычно используется для подключения middleware и инструментов вроде Redux DevTools.

**Вопрос**: Что возвращает редьюсер, если экшен ему не знаком? **Ответ**: Он возвращает текущее состояние без изменений. Это важно, чтобы не ломать логику в других редьюсерах.

**Вопрос**: Почему важно не мутировать стейт в редьюсере? **Ответ**: Нарушается принцип предсказуемости, Redux не сможет корректно понять, что состояние изменилось. Может привести к ошибкам и сбоям.

**Вопрос**: Можно ли иметь несколько стооров (store) в одном React-приложении? **Ответ**: Теоретически да, но на практике обычно используют один store для централизованного управления состоянием. Множество стооров усложняют приложение.

**Вопрос**: Как обрабатывать ошибки в redux-thunk? **Ответ**: Внутри thunk-экшенов использовать try...catch, диспатчить экшены успеха и ошибки, обрабатывать в редьюсерах.

</details>

<details>
  <summary>5. Общие подходы и концепции</summary>

**Вопрос**: Что такое REST и чем отличается от SOAP? **Ответ**: REST — архитектурный стиль, в котором используются HTTP-методы (GET, POST и т.д.) для работы с ресурсами. SOAP — протокол обмена сообщениями, более сложный, использует XML и WSDL.

**Вопрос**: Что такое HTTP-методы и для чего они нужны? **Ответ**: GET, POST, PUT, PATCH, DELETE и др. Определяют, какое действие должно совершаться над ресурсом: получение данных, создание, обновление, удаление.

**Вопрос**: Что такое CORS? **Ответ**: Механизм, позволяющий ограничивать/разрешать запросы к ресурсам с других доменов. Управляется заголовками браузера и сервера.

**Вопрос**: Как работать с формами и загрузкой файлов на фронтенде? **Ответ**: Использовать <form> с соответствующими атрибутами, для загрузки файлов — `<input type="file">`. На стороне JS можно использовать FormData для отправки данных через fetch/AJAX.

**Вопрос**: Что такое JSON Web Token (JWT)? **Ответ**: Способ представления «заявленных» данных (claims) в виде зашифрованного токена. Используется для авторизации, передаётся между клиентом и сервером.

**Вопрос**: Для чего нужен WebSocket? **Ответ**: WebSocket — протокол для двунаправленной связи между клиентом и сервером в режиме реального времени (чаты, онлайн-игры, биржевые котировки).

**Вопрос**: Какие заголовки HTTP можно использовать для оптимизации работы с кэшем? **Ответ**: Cache-Control, Expires, ETag, Last-Modified. Эти заголовки помогают управлять сроком и условиями кэширования ответов.

**Вопрос**: В чём разница между «hosted» и «self-hosted» решениями для CI/CD? **Ответ**: «Hosted» (например, GitHub Actions) запускается в облаке поставщика, «self-hosted» работает на собственных серверах компании. Выбор зависит от бюджета и требований безопасности.

**Вопрос**: Что означает SPA (Single Page Application)? **Ответ**: Приложение с единственной HTML-страницей, где контент динамически подгружается и обновляется без полной перезагрузки страницы.

**Вопрос**: Как улучшить SEO для SPA? **Ответ**: Использовать серверный рендеринг, динамический рендеринг (Prerender), или отдельные механизмы, позволяющие поисковым ботам индексировать контент.

**Вопрос**: Что такое Progressive Web App (PWA)? **Ответ**: Веб-приложение со способностями нативного приложения: офлайн-работа, пуш-уведомления, иконка на главном экране. Использует Service Worker, манифест и HTTPS.

**Вопрос**: Чем отличается sessionStorage от localStorage? **Ответ**: sessionStorage хранит данные в рамках одной сессии вкладки, при закрытии вкладки данные стираются. localStorage сохраняет данные без ограничения сессией, пока пользователь или код их не удалит.

**Вопрос**: Что такое CDN и зачем он нужен? **Ответ**: CDN (Content Delivery Network) — сеть серверов, расположенных по всему миру, для быстрой доставки контента пользователям. Уменьшает время загрузки, повышает производительность.

**Вопрос**: Как проверить, что код работает быстро (performance)? **Ответ**: Использовать инструменты профилирования, например Chrome DevTools, Lighthouse, смотреть на метрики, такие как TTFB, FCP, Time to Interactive.

**Вопрос**: Что такое SOLID-принципы? **Ответ**: Пять принципов объектно-ориентированного программирования (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion), помогают писать поддерживаемый код.

**Вопрос**: Как работает «Lazy Loading» компонентов в React? **Ответ**: Используется React.lazy() и Suspense, чтобы загрузить компонент при его фактическом запросе (динамическая подгрузка кода).

**Вопрос**: Что такое «Micro Frontends»? **Ответ**: Подход к разработке фронтенда, при котором приложение разбивается на независимые модули или проекты, которые могут разрабатываться и внедряться отдельно.

**Вопрос**: Как настроить Linting/Formatting в React-проекте? **Ответ**: Использовать ESLint для линтинга, Prettier для форматирования. Часто настраивают совместную работу, чтобы Prettier обрабатывал формат, а ESLint проверял правила кода.

**Вопрос**: Что такое «code splitting» в Webpack? **Ответ**: Разделение кода на отдельные чанки, которые подгружаются по мере необходимости (динамический импорт). Уменьшает время первоначальной загрузки.

**Вопрос**: Что такое «source map»? **Ответ**: Файл, сопоставляющий скомпилированный/минифицированный код с исходным, чтобы отлаживать код в браузере, видя исходные строки.

**Вопрос**: Как работает hot reloading (HMR)? **Ответ**: Механизм Webpack, который обновляет модули в реальном времени без перезагрузки всей страницы, сохраняя состояние приложения.

**Вопрос**: Что такое Monorepo и зачем он может понадобиться? **Ответ**: Monorepo — стратегия хранения нескольких проектов/пакетов в одном репозитории. Упрощает совместное использование кода, централизованное управление зависимостями.

**Вопрос**: Как обрабатывать технический долг? **Ответ**: Определить приоритеты, регулярно выделять время (refactoring sprints) на оплату техдолга, устанавливать стандарты кода и проводить код-ревью.

**Вопрос**: Что такое agile-методологии и чем они полезны? **Ответ**: Agile — набор принципов гибкой разработки (Scrum, Kanban). Они повышают адаптивность к изменениям, улучшают коммуникацию в команде и качество продукта.

**Вопрос**: Зачем использовать Git Hooks? **Ответ**: Чтобы автоматически выполнять скрипты при определённых действиях в Git (commit, push, merge). Например, запуск тестов, линтера перед коммитом.

**Вопрос**: Что делать, если приложение ломается после сборки на продакшене, а на dev всё работало? **Ответ**: Проверить environment-переменные, пути, минификацию, конфигурацию Webpack, различия между dev и prod сборкой, логирование ошибок в консоль браузера.

**Вопрос**: Что такое TDD (Test-Driven Development)? **Ответ**: Подход, при котором сначала пишутся тесты, которые не проходят, затем пишется код для прохождения тестов, и цикл повторяется (Red-Green-Refactor).

**Вопрос**: Как тестировать React-компоненты? **Ответ**: Использовать фреймворки (Jest, React Testing Library). Писать unit-тесты на логику, проверять рендер и поведение. Иногда использовать интеграционные тесты.

**Вопрос**: Чем отличается unit-тест от интеграционного теста? **Ответ**: Юнит-тест проверяет отдельный модуль (функцию, компонент) изолированно. Интеграционный тест проверяет связку модулей и их взаимодействие.

**Вопрос**: Что такое Snapshot-тесты? **Ответ**: Тесты, которые сохраняют снимок рендера компонента (например, JSON-структуру). При последующих запусках сравнивают текущее состояние со снимком.

**Вопрос**: Что проверяет E2E (end-to-end) тест? **Ответ**: Тестирует приложение целиком, имитирует действия пользователя в реальном браузере, проверяя корректность всей цепочки (frontend + backend).

**Вопрос**: Какие наиболее популярные библиотеки для E2E-тестирования? **Ответ**: Cypress, Playwright, Selenium (WebDriver), Puppeteer.

**Вопрос**: Зачем нужен Docker для фронтенд-разработки? **Ответ**: Чтобы обеспечить единое окружение для запуска приложения, независимое от настроек локальных машин. Упрощает деплой и CI/CD.

**Вопрос**: Что такое «feature branch workflow» в Git? **Ответ**: Каждый разработчик работает над своей фичей в отдельной ветке, затем создаёт Pull Request в основную ветку, чтобы объединить изменения.

**Вопрос**: Как уменьшить размер бандла? **Ответ**: Удалить неиспользуемый код (tree shaking), использовать code splitting, динамические импорты, минификацию, gzip-сжатие и оптимизировать зависимости.

**Вопрос**: Что такое Accessibility (A11y)? **Ответ**: Практика создания сайтов доступными для людей с ограниченными возможностями (использование экранных читалок, клавиатурной навигации, ARIA-атрибутов).

**Вопрос**: Как проверить доступность веб-страницы? **Ответ**: Использовать Lighthouse, axe, WAVE, NVDA или VoiceOver (экранные читалки), проверять контрастность, правильную разметку и т.д.

**Вопрос**: Что такое Webpack loader и плагин (plugin)? **Ответ**: Loaders трансформируют исходный код (например, babel-loader). Plugins расширяют функциональность (например, HtmlWebpackPlugin создает HTML-файл).

**Вопрос**: Как работает ESLint? **Ответ**: Анализирует код на основе заданных правил, находя ошибки и несоответствия стилю. Можно подключать пресеты (Airbnb, Google) и свои правила.

**Вопрос**: Что такое «source control branching strategy»? **Ответ**: Способ организации веток в репозитории (Git-flow, GitHub Flow). Определяет, как и когда создавать ветки, выпускать релизы и интегрировать изменения.

**Вопрос**: Чем отличается Git merge от Git rebase? **Ответ**: Merge создаёт дополнительный «merge commit» и сохраняет историю ветвления. Rebase «переигрывает» коммиты на новой базе, делая историю линейной.

**Вопрос**: Что такое реактивное программирование (Reactive Programming)? **Ответ**: Парадигма, в которой поток данных обрабатывается асинхронно, а изменения данных автоматически передаются подписчикам (RxJS, например).

**Вопрос**: Как улучшить безопасность фронтенд-приложения? **Ответ**: Использовать HTTPS, безопасное хранение токенов (HttpOnly cookies, Local Storage при необходимости), защиту от XSS (escape input), CORS, Content Security Policy, лимитировать brute force и т.д.

**Вопрос**: Что такое «XSS» и как с ним бороться? **Ответ**: Cross-Site Scripting — уязвимость, позволяющая внедрить вредоносный скрипт. Защита: экранировать ввод (sanitizing), использовать dangerouslySetInnerHTML осторожно, выставлять заголовки безопасности.

**Вопрос**: Как настроить защиту от CSRF? **Ответ**: Использовать токены (CSRF-tokens), которые проверяются при POST-запросах, либо хранить сессию в HttpOnly cookie и использовать анти-CSRF-токен в заголовках.

**Вопрос**: Что такое «Service Worker»? **Ответ**: Скрипт, работающий в фоновом процессе браузера, может перехватывать запросы, кэшировать ресурсы, обеспечивать офлайн-режим и пуш-уведомления.

**Вопрос**: Как реализовать офлайн-режим в PWA? **Ответ**: С помощью Service Worker, который кэширует необходимые файлы (HTML, CSS, JS, изображения). При отсутствии сети контент берётся из кэша.

**Вопрос**: Что такое «IndexedDB»? **Ответ**: Встроенная база данных в браузере для хранения значительного объёма структурированных данных (key-value). Работает асинхронно.

**Вопрос**: Как подключить стороннюю библиотеку к React/TypeScript проекту? **Ответ**: Установить через npm/yarn, импортировать в нужном месте. При необходимости установить типы @types/имябиблиотеки. Проверить конфигурацию TS.

**Вопрос**: Что такое «semantic HTML»? **Ответ**: Использование тегов, которые отражают смысл (header, main, footer, article), чтобы улучшить доступность, SEO и структуру документа.

**Вопрос**: Как работает методология БЭМ (BEM) в CSS? **Ответ**: Блок (Block), Элемент (Element), Модификатор (Modifier). Имена классов пишутся с учётом этой структуры, например: .block__element--modifier.

**Вопрос**: Почему важно не хардкодить цвета и другие стили в JS? **Ответ**: Стили лучше хранить централизованно (CSS или Theme), чтобы упрощать поддержку и переиспользование, особенно в больших проектах.

**Вопрос**: Что такое «Atomic CSS»? **Ответ**: Подход, когда стили разбиваются на маленькие утилитарные классы (одна цель — один класс). Например: .p-2, .text-center. Уменьшает дублирование, но может усложнить читаемость HTML.

**Вопрос**: Что такое «responsive design»? **Ответ**: Подход при котором интерфейс адаптируется под различные размеры экранов и устройства, используя медиа-запросы, гибкие сетки и т.д.

**Вопрос**: Как проверить верстку на соответствие макету? **Ответ**: Использовать DevTools, наложить макет (если доступен в виде картинки) в режиме наложения (overlay), также пользоваться Pixel Perfect плагинами.

**Вопрос**: Зачем нужен CSS-in-JS? **Ответ**: Позволяет инкапсулировать стили вместе с компонентом, использовать динамические стили на основе пропов. Примеры: styled-components, emotion.

**Вопрос**: В чём преимущество Storybook для фронтенд-разработки? **Ответ**: Storybook позволяет разрабатывать компоненты изолированно, документировать их, быстро просматривать различные состояния и повышать переиспользование.

**Вопрос**: Как подключить шрифты в проект? **Ответ**: Через @font-face в CSS, указав путь к файлам шрифтов, или использовать CDN (Google Fonts). Желательно загружать в форматах WOFF/WOFF2.

**Вопрос**: Как настроить «тему» (theme) в React-приложении? **Ответ**: Использовать контекст (ThemeContext) или сторонние библиотеки (например, styled-components ThemeProvider), где хранятся основные цвета, шрифты и т.д.

**Вопрос**: Чем отличается CSS Grid от Flexbox? **Ответ**: Flexbox оптимизирован для одномерных раскладок (строка или колонка), Grid — для двумерных макетов, где контролируется и строка, и столбец.

**Вопрос**: Что такое PostCSS? **Ответ**: Инструмент для трансформации CSS с помощью плагинов (autoprefixer, nested, cssnano и т.д.). Модульно расширяет функциональность CSS.

**Вопрос**: Как использовать SVG в React? **Ответ**: Можно импортировать как компонент или инлайн-содержимое svg, передавая пропы напрямую. Либо использовать `<img src="...">`, но теряются некоторые возможности стилизации.

**Вопрос**: Что такое Pixel Density (Retina) и как с этим работать? **Ответ**: Устройства Retina имеют повышенную плотность пикселей. Нужно использовать изображения с увеличенным разрешением (2x, 3x) или векторную графику.

**Вопрос**: Как сделать темную/светлую тему (dark/light mode)? **Ответ**: Хранить в состоянии (например, Redux или Context), переключать классы/переменные CSS (или тему в styled-components). Поддерживать prefers-color-scheme (media query).

**Вопрос**: Что такое CSS переменные (Custom Properties)? **Ответ**: Переменные, задаваемые в CSS через --my-var: value;, используемые через var(--my-var). Можно динамически менять их через JS.

**Вопрос**: Какие основные проблемы при адаптивной верстке? **Ответ**: Переполнение контейнеров, неправильные медиазапросы, резкое изменение пропорций изображений, сложные сетки, разные DPI, кроссбраузерность.

**Вопрос**: Как протестировать приложение в разных браузерах? **Ответ**: Использовать сервисы типа BrowserStack, Sauce Labs, локальные виртуальные машины, встроенные инструменты эмуляции в DevTools. Проверять Edge, Firefox, Safari, IE (при необходимости).

**Вопрос**: Что такое «ARIA-атрибуты»? **Ответ**: Набор специальных атрибутов для улучшения доступности веб-приложений (aria-label, aria-hidden и т.д.). Подсказывают экранным читалкам, как интерпретировать элементы.

**Вопрос**: Как работают Relative и Absolute импорты в TypeScript/JS? **Ответ**: Relative идут от текущей позиции (./, ../). Absolute — через корневую директорию (при правильной настройке tsconfig paths или вебпака alias).

**Вопрос**: Что такое Babel? **Ответ**: Транспайлер, который компилирует современный JS (ES6+) в более совместимую версию для старых браузеров. Можно подключить плагины для JSX, TypeScript.

**Вопрос**: Как настроить Husky? **Ответ**: Устанавливаете husky и прописываете в package.json скрипты для хуков (pre-commit, pre-push). Затем создаёте файлы конфигурации .husky/pre-commit с нужными командами.

**Вопрос**: Что делать, если библиотека не имеет типовых определений? **Ответ**: Либо написать собственные типы (d.ts), либо использовать any, либо найти типы в DefinitelyTyped (@types/что-то), если они существуют.

**Вопрос**: Как правильно организовать структуру проекта на React + Redux + TypeScript? **Ответ**: Общий подход:

    src/

        components/

        pages/

        store/

            actions/

            reducers/

            types/

        hooks/

        utils/

Но это зависит от команды/проекта.

**Вопрос**: Как бороться с множественными re-render компонентов? **Ответ**: Использовать мемоизацию (React.memo, useCallback, useMemo), оптимизировать структуру стейта, разбивать компоненты, не передавать новые объекты/функции без надобности.

**Вопрос**: Что делает библиотека Immer в Redux? **Ответ**: Позволяет писать «мутабельный» код (с оператором =), но под капотом обеспечивает иммутабельность. Упрощает редьюсеры.

**Вопрос**: Что такое “compound components” в React? **Ответ**: Паттерн, при котором компонент состоит из нескольких вложенных «подкомпонентов» (например, <Dropdown.Menu>, <Dropdown.Item>), объединённых общим состоянием.

**Вопрос**: Какие «стратегии кеширования» можно использовать на фронте? **Ответ**: Stale-While-Revalidate, Cache-first, Network-first, Network-only, Cache-only, комбинированные паттерны в PWA/Service Worker.

**Вопрос**: Что такое Webpack Tree Shaking? **Ответ**: Процесс удаления неиспользуемых (dead) экспортов при сборке, уменьшает размер финального бандла.

**Вопрос**: Как передавать данные между компонентами, не являясь родственными (когда нет общего родителя)? **Ответ**: Использовать Context, глобальный стейт (Redux/MobX), или передавать функции коллбэки через цепочку (проп drilling) при необходимости.

**Вопрос**: Что такое Refs Forwarding (React.forwardRef)? **Ответ**: Механизм, позволяющий компоненту передать ref во внутренний дочерний элемент. Используется для доступа к DOM-элементу из родителя.

**Вопрос**: Для чего нужен Suspense в React? **Ответ**: Для отложенной загрузки компонентов (code splitting) и отображения запасного UI (fallback) во время асинхронных операций (React.lazy).

**Вопрос**: Что такое Redux Toolkit (RTK)? **Ответ**: Набор инструментов, упрощающий работу с Redux: createSlice, configureStore, createAsyncThunk. Уменьшает шаблонный код и рекомендует лучшие практики.

**Вопрос**: Как организовать межкомпонентную коммуникацию без Redux? **Ответ**: Через React Context, пользовательские хуки, коллбэки (prop drilling), Event Emitter (но обычно реже применяется напрямую).

**Вопрос**: Что такое «Atomic design»? **Ответ**: Методология организации UI на уровне атомов (кнопки, инпуты), молекул (комбинации атомов), организмов (сложные блоки), шаблонов и страниц.

**Вопрос**: Как использовать React Router с TypeScript? **Ответ**: Устанавливаете react-router-dom и типы @types/react-router-dom. Типизируете параметры в маршрутах, хуках (useParams, useNavigate) через дженерики, если нужно.

**Вопрос**: Что такое «Hydration» в React SSR? **Ответ**: Процесс, при котором React «привязывает» события и функциональность к уже сгенерированному на сервере HTML, превращая статический контент в интерактивный.

**Вопрос**: Как обновлять зависимые пакеты в проекте? **Ответ**: Использовать npm-check-updates или вручную менять версии в package.json, потом проверять совместимость и тестить приложение.

**Вопрос**: Что такое «чистая функция» (pure function)? **Ответ**: Функция без побочных эффектов, результат зависит только от входных аргументов, при одинаковых входных данных всегда возвращает одинаковый результат.

**Вопрос**: Чем отличается атрибут HTML5 data-* от обычных атрибутов? **Ответ**: data-* — способ хранить пользовательские данные в атрибутах, доступных через dataset в JS. Обычные атрибуты имеют особую логику или семантику, data-* используется для произвольных данных.

**Вопрос**: Что важнее для Junior/Middle: знать много технологий или глубже понимать используемые? **Ответ**: Глубокое понимание основных инструментов и концепций важнее, чем поверхностные знания большого числа технологий.

</details>

## Middle / middle + (gpt)

<details>
  <summary>Раздел 1. Расширенные вопросы по JavaScript</summary>

Вопрос: Что такое «TDZ» (Temporal Dead Zone) в JavaScript? Ответ: TDZ — это период времени от начала области видимости (блока) до инициализации переменной, объявленной через let или const. В этот период доступ к переменной невозможен, что предотвращает использование до фактического объявления.

Вопрос: Как устроен механизм «private fields» в современных классах JavaScript? Ответ: В современных спецификациях можно объявлять приватные поля, используя #. Пример:

    class Person {
        #name;
        constructor(name) {
            this.#name = name;
            }
        getName() {
            return this.#name;
        }
    }

Эти поля недоступны за пределами класса.

Вопрос: Как работает оптимизация «Tail Call Optimization»? Реализована ли она в современных движках? Ответ: Tail Call Optimization (TCO) — это оптимизация рекурсивных вызовов, когда возвращается результат вызова функции непосредственно. Многие JS-движки (V8 в Chrome) не полностью поддерживают TCO для всего кода, но ES2015 предполагает её наличие. На практике TCO в современных браузерах чаще всего недоступна или работает ограниченно.

Вопрос: Как работает «WeakMap» и «WeakSet»? Ответ: WeakMap и WeakSet — это структуры данных, где ключи хранятся «слабой» ссылкой. Если на объект нет больше сильных ссылок, он может быть очищен сборщиком мусора, даже если находится в WeakMap/WeakSet. Это используется для мемоизации или хранения данных о внешних объектах, чтобы не мешать сборке мусора.

Вопрос: Что такое «Proxy» в JavaScript? Ответ: Proxy — это объект-обёртка, который позволяет перехватывать и переопределять некоторые операции (например, чтение/запись свойств, вызов функций, проверку свойств). Можно использовать для «магических» свойств, валидации, прослушивания и т.п.

Вопрос: Как можно «заморозить» объект (сделать неизменяемым)? Ответ: Использовать Object.freeze(obj), который запрещает добавление/удаление/изменение свойств. Это неглубокая заморозка: вложенные объекты остаются мутируемыми.

Вопрос: Как проверить, является ли значение «NaN» в JavaScript? Ответ: Правильный способ — Number.isNaN(value). Нельзя использовать value === NaN, так как NaN не равен даже самому себе.

Вопрос: Как проверить равенство объектов? Ответ: Объекты сравниваются по ссылке, т.е. obj1 === obj2 проверяет, указывают ли обе переменные на один и тот же объект. Для структурного сравнения нужно рекурсивно сравнивать поля или использовать стороннюю утилиту (например, lodash.isEqual).

Вопрос: Чем полезна функция Object.defineProperty? Ответ: Позволяет тонко настраивать свойства объекта, указывая атрибуты (configurable, enumerable, writable, get, set). Можно создавать геттеры/сеттеры и запрещать изменение свойств.

Вопрос: Как обработать несколько промисов параллельно? Ответ: Использовать `Promise.all([...])`. Если один из промисов отклоняется, весь промис возвращает ошибку. Для независимых промисов, где важно получить часть результатов, можно `Promise.allSettled([...])`.

Вопрос: Как работает Promise.race? Ответ: Promise.race возвращает результат первого завершившегося (fulfilled или rejected) промиса из списка. Полезно для таймаутов или конкурентных запросов.

Вопрос: В чём разница между document.querySelector и document.getElementById? Ответ: querySelector позволяет находить элемент по любому CSS-селектору, возвращает первый найденный элемент. getElementById ищет элемент по идентификатору, обычно быстрее, но заточен только под поиск по id.

Вопрос: Что делает метод массива flatMap? Ответ: flatMap применяет функцию к каждому элементу массива и «выравнивает» (flattens) результат на один уровень. Комбинация map + flat(1).

Вопрос: Какие есть особенности поведения this при использовании методов объекта как колбэков? Ответ: Если передать метод объекта в колбэк без бинга, при вызове this может стать undefined или глобальным объектом. Нужно использовать .bind(this) или стрелочные функции, чтобы сохранить контекст.

Вопрос: Что такое «Reflow» и «Repaint» в контексте браузера? Ответ:

Reflow (перекомпоновка) — когда браузер пересчитывает расположение элементов (layout) на странице.
Repaint (перерисовка) — когда изменяются визуальные стили (цвет, фон), но не меняется положение/размер.
Чрезмерные reflow/repaint снижают производительность.
Вопрос: Что такое «Intersection Observer»? Ответ: API для отслеживания пересечения элемента с областью просмотра (viewport) или с родительским элементом. Позволяет эффективно реализовывать ленивую загрузку картинок, бесконечный скролл.

Вопрос: Чем отличается «passive event listener» от обычного? Ответ: При passive: true в addEventListener вы сообщаете браузеру, что не будете вызывать preventDefault в колбэке, а значит прокрутка может работать более плавно.

Вопрос: Что такое «Web Workers»? Ответ: Механизм запуска фоновых потоков (worker) в браузере, которые выполняют код без блокировки основного потока (UI). Используется для тяжёлых вычислений.

Вопрос: Как работает Intl API в JavaScript? Ответ: Набор API для интернационализации (Intl.NumberFormat, Intl.DateTimeFormat и т.д.), позволяющих форматировать числа, даты, валюты в локалях без дополнительных библиотек.

Вопрос: Что делают Object.seal и Object.preventExtensions? Ответ:

Object.seal запрещает добавлять или удалять свойства, но позволяет менять значения существующих.
Object.preventExtensions запрещает только добавлять новые свойства.

</details>

<details>
  <summary>Раздел 2. Продвинутые вопросы по React</summary>

Вопрос: Что такое «React Fiber»? Ответ: Это внутренняя реализация механизма согласования (reconciliation) в React, начиная с версии 16. «Fiber» — структура данных, описывающая компонент. Благодаря Fiber React может прерывать долгие рендеры и обновлять UI более плавно.

Вопрос: Какие особенности у «конкурентного рендеринга» (Concurrent Rendering) в React? Ответ: Concurrent Rendering (в новой архитектуре React) позволяет прерывать рендер, если приходит более важное событие. Это улучшает отзывчивость UI, но требует новых API и паттернов (например, useTransition).

Вопрос: Как работает «Suspense» для данных, а не только для code-splitting? Ответ: Suspense может «приостанавливать» рендер компонента до тех пор, пока данные не будут загружены. Это требует специального подхода к фетчингу данных (React.lazy для компонентов, Relay/React 18 — для данных). Важно, чтобы «задержка» не ломала весь UI.

Вопрос: Как использовать «Error Boundaries» с функциональными компонентами? Ответ: Ошибки в функциональных компонентах нельзя «поймать» хуком напрямую. Нужно использовать классовый компонент, реализующий componentDidCatch. Либо использовать React Error Boundary library. React планирует в будущем улучшить обработку ошибок в функциональных компонентах, но пока только классы.

Вопрос: Что такое useLayoutEffect и чем он отличается от useEffect? Ответ: useLayoutEffect вызывается синхронно после всех изменений DOM, но до того, как браузер «отрисует» экран. Используется, когда нужно измерить DOM-элементы и сразу же что-то скорректировать. useEffect вызывается асинхронно после рендера.

Вопрос: Чем полезен «Render Props» паттерн? Ответ: Позволяет передавать функцию для рендера дочерних элементов. Паттерн решает задачу по делению логики между компонентами, давая гибкость, похожую на HOC, но более явно через JSX. Однако с введением хуков чаще используют композицию хуков, а не render props.

Вопрос: Что такое «PureComponent» и «React.memo»?
Ответ: React.PureComponent — классовый компонент, реализующий поверхностное сравнение пропсов/стейта в shouldComponentUpdate. React.memo — аналог для функциональных компонентов, мемоизирующий результат рендера при неизменённых пропах.

Вопрос: В чём особенности «Strict Mode» для хуков? Ответ: В режиме Strict Mode в Dev-режиме React дважды вызывает некоторые хуки (особенно useEffect) для выявления побочных эффектов, которые не должны вызываться повторно. Это может приводить к «странному» поведению, но важно для улучшения качества кода.

Вопрос: Как оптимизировать работу со списками (большое количество элементов) в React? Ответ: Использовать виртуализацию списков (react-window, react-virtualized), что позволяет рендерить на экране только ту часть списка, которая видна пользователю в данный момент, сокращая нагрузку на DOM.

Вопрос: Что делать, если нужно добавить логику жизненного цикла в функциональный компонент? Ответ: Использовать хуки: useEffect (аналог componentDidMount/Update/Unmount) и другие хуки, разнесённые по назначению. Классовых методов в функциональных компонентах нет, вся «жизнь» через эффекты.

Вопрос: Как реализовать контекст с динамическим значением без лишних перерисовок? Ответ: Разделить контекст на более мелкие, мемоизировать значение контекста, использовать разделение состояния. Либо использовать паттерны, где контекст хранит только идентификатор, а данные берутся из мемоизированного селектора.

Вопрос: Что такое «React Performance Profiler»? Ответ: Это инструмент (в DevTools React) для анализа потраченного времени рендера компонентов. Позволяет увидеть, какие компоненты слишком часто пересоздаются или «тратят» много времени на обновление.

Вопрос: Как правильно работать с формами в React, учитывая производительность и валидацию? Ответ: Часто используют библиотеки (Formik, react-hook-form). Они оптимизируют обновления state, мемоизируют поля и дают удобные средства валидации, уменьшая количество ререндеров.

Вопрос: В чём разница между «client-side routing» и «server-side routing» в React-приложениях? Ответ: При client-side роутинге React управляет переходами без перезагрузки страницы (используя History API). При server-side роутинге каждое новое URL-запрос обрабатывает сервер и отрисовывает новую страницу. Next.js использует обе стратегии: серверный рендер и клиентский роутинг.

Вопрос: Как можно использовать «portals» в сочетании с хуками? Ответ: Порталы — это способ рендерить дочерний элемент за пределами родительского DOM-дерева. Для управления состоянием внутри портала можно использовать те же хуки (useState, useEffect и т.д.). Важно убедиться, что контекст доступен (если порталы в пределах одного дерева React).

Вопрос: Что такое «Recoil», «Zustand» или «Jotai» в контексте React? Ответ: Это альтернативы Redux для глобального состояния. Они предлагают более гибкий подход, часто с меньшим количеством кода и другой архитектурой (атомарные стейты, селекторы и т.п.).

Вопрос: Как работает React DevTools «Highlight Updates»? Ответ: Этот режим подсвечивает обновляющиеся области приложения, показывая, где происходит ререндер. Это помогает выяснить, какие компоненты перерисовываются слишком часто и оптимизировать структуру.

Вопрос: Можно ли отрисовывать React-компоненты в Web Worker? Ответ: Не напрямую, так как Web Worker не имеет доступа к DOM. Есть эксперименты (React-приложение в Worker, передача патчей в главный поток), но из коробки React не поддерживает полноценный рендер в Worker.

Вопрос: Как отобразить очень большие таблицы (десятки тысяч строк) в React? Ответ: Использовать виртуализацию (React Virtualized / React Window) или «infinite scrolling». Нельзя загружать все строки в DOM одновременно — это повлияет на производительность.

Вопрос: В чём суть «CSS-in-JS» в экосистеме React? Ответ: CSS-in-JS — подход, когда стили пишутся непосредственно в JS, а на уровне сборки/рантайма формируются классы. Примеры: styled-components, Emotion. Даёт динамику и изоляцию стилей, но может влиять на производительность и сложность.

</details>

<details>
  <summary>Раздел 3. TypeScript — углублённые вопросы</summary>

Вопрос: Что такое «declaration merging» в TypeScript? Ответ: Declaration merging позволяет объединять несколько объявлений одного и того же имени (interface, namespace). TypeScript склеивает их в одно объявление, расширяя список свойств или пространств имён.

Вопрос: Как работает «type widening» и «type narrowing»? Ответ:

Widening: когда вы присваиваете что-то вроде let x = null, TS может вывести тип как any или string | null и т.п.
Narrowing: при условных операциях (например, проверка typeof) TS сужает тип, исключая невозможные ветки.
Вопрос: Как определить «Branded Type» (Nominal Typing) в TypeScript? Ответ: Делают через пересечение типов с уникальным полем. Например:

    type USD = number & { readonly brand: unique symbol };

Так создают «метку» типа, чтобы отличать один тип number от другого.

Вопрос: Что такое «Mapped Types»? Ответ: Механизм создания типов, проходясь по ключам другого типа. Например:

    type Readonly<T> = {
        readonly [P in keyof T]: T[P];
    };

Это основа утилитных типов вроде Partial, Readonly, Record.

Вопрос: Какая разница между «interface» и «type» с точки зрения расширения? Ответ: Интерфейсы можно «мерджить» и делать extends. Типы более гибкие (могут быть union, intersection и т.д.), но не поддерживают повторные объявления для объединения.

Вопрос: Как работает keyof? Ответ: keyof возвращает объединение всех ключей (названий свойств) переданного типа. Например keyof { a: string; b: number } будет 'a' | 'b'.

Вопрос: Что такое Conditional Types? Ответ: Условные типы (например, T extends U ? X : Y), позволяющие строить логику на уровне типов. Исполняются на этапе компиляции, выводя результат в зависимости от того, соответствует ли T типу U.

Вопрос: Зачем нужны «Utility Types», например Partial, Pick, Omit? Ответ: Утилиты упрощают создание типов на базе уже существующих. Partial делает все поля опциональными, Pick выбирает набор ключей, Omit — исключает некоторые ключи. Это ускоряет разработку и минимизирует дублирование.

Вопрос: Как описать тип для функции, принимающей переменное число аргументов? Ответ: Использовать рест-параметры:

    function myFunc(...args: number[]): number {
        return args.reduce((a,b) => a+b, 0);
    }

Или через кортежи в дженериках, если нужны определённые ограничения.

Вопрос: Как проверить, что объект соответствует интерфейсу только на этапе разработки, не выбрасывая ошибку в рантайме? Ответ: TypeScript не проводит рантайм-проверки типов. Нужно использовать либо сторонние библиотеки (io-ts, runtypes), либо писать собственные проверки (type guards). На этапе компиляции TS только «подсвечивает» несоответствия в коде.

Вопрос: Как правильно типизировать React-компонент, который имеет generic? Ответ: Можно сделать так:

    type MyComponentProps<T> = {
        items: T[];
        ...
    };
    
    function MyComponent<T>({ items }: MyComponentProps<T>) {
        ...
    }

Или через React.FC<MyComponentProps<T>>, соблюдая синтаксис <T>.

Вопрос: Что такое «discriminated unions»? Ответ: Это паттерн, где несколько вариантов union-типа имеют общий «дискриминирующий» ключ (например, type: "circle" | "square"). TS может сужать тип по значению этого ключа в switch или условиях.

Вопрос: Какие «strict» настройки есть в TypeScript и зачем они нужны? Ответ: Ключевые: strictNullChecks, noImplicitAny, strictBindCallApply, strictFunctionTypes, strictPropertyInitialization. Они делают типизацию более строгой, помогая избежать скрытых ошибок.

Вопрос: Как в TS гарантировать неизменяемость объектов? Ответ: Можно использовать readonly поля, Readonly mapped type, а также замораживать объекты в рантайме (но TS это не может строго гарантировать без runtime-проверок). Для полных гарантий — иммутабельные структуры данных и линтер-правила.

Вопрос: Что такое «type predicates» или «type guards»? Ответ: Это функции, которые возвращают булево значение и дают TS понять, что внутри if ветки тип более «узкий». Пример:

    function isString(x: unknown): x is string {
        return typeof x === 'string';
    }

Если в `if (isString(value))`, то value — точно string.

Вопрос: Как типизировать модуль с динамическими именами экспорта? Ответ: Использовать index signature. Например, если объект может иметь разные строковые ключи, каждый из которых — функция, мы пишем:

    interface Commands {
        [commandName: string]: () => void;
    }

Вопрос: Как применить this типизацию в методах класса? Ответ: Можно указывать this: ClassName в сигнатуре метода:

    class MyClass {
        method(this: MyClass, arg: number) {
        ...
        }
    }

Это предотвращает неправильные вызовы, где this не является экземпляром MyClass.

Вопрос: Как создавать декларации типов для внешних JS-библиотек без типизации? Ответ: Создать .d.ts файл с объявлениями (declare module 'some-lib') и описать нужные интерфейсы, классы, функции. Либо опубликовать их в DefinitelyTyped.

Вопрос: Что делает оператор ! (Non-Null Assertion Operator) в TypeScript? Ответ: Сообщает компилятору, что значение не является null или undefined. Используется осторожно, так как может скрывать потенциальные ошибки:

    const el = document.getElementById('foo')!;

Вопрос: Можно ли выполнять «type-level» вычисления, используя условные типы? Ответ: Да, TS поддерживает сложные вычисления на уровне типов. Используя условные типы, mapped types, рекурсивные типы, можно создавать «виртуальные» вычисления, но это может быть довольно сложным и вызывать проблемы с производительностью компиляции.

</details>

<details>
  <summary>Раздел 4. Redux / State Management — продвинутые вопросы</summary>

Вопрос: В чём суть «Redux Toolkit» (RTK) и чем он лучше «ручной» конфигурации Redux? Ответ: RTK упрощает настройку store, уменьшает бойлерплейт кода для редьюсеров, экшенов и т.д. Предоставляет удобные утилиты (createSlice, createAsyncThunk) и автоматически включает такие настройки, как Immer для иммутабельности и Redux DevTools.

Вопрос: Как работает «Immer» внутри Redux Toolkit? Ответ: Immer перехватывает «мутабельные» операции (например, state.someValue = 123) и под капотом создаёт новое иммутабельное состояние с учётом изменений. Таким образом, код пишется как будто «мутируемый», но реально сохраняется иммутабельность.

Вопрос: В чём отличия Redux Thunk от Redux Saga? Ответ:

Redux Thunk: даёт возможность диспатчить функции вместо plain-objects, внутри которых делаются асинхронные запросы и по завершении диспатчатся экшены.
Redux Saga: использует генераторы, позволяя описывать асинхронную логику в виде «сага-функций», которые могут «слушать» экшены, отменять эффекты, параллелить, ретраить и т.д.
Вопрос: Чем полезен middleware «redux-logger»? Ответ: Логирует экшены, предыдущий и следующий стейт в консоли. Упрощает отладку приложения, особенно на стадии разработки.

Вопрос: Как организовать комплексный SSR с Redux? Ответ: При SSR создаётся store на сервере, диспатчится нужные экшены (например, загрузка данных), после чего состояние сериализуется и передаётся клиенту. Клиент при гидрации получает то же состояние, чтобы избежать расхождений.

Вопрос: Что такое «reselect» и как оно помогает в Redux-приложениях? Ответ: reselect — библиотека для мемоизации селекторов. Она предотвращает повторные вычисления, если часть состояния не менялась, улучшая производительность при выборке данных из store.

Вопрос: Как в Redux избежать «props drilling» при сложной вложенности компонентов? Ответ: С Redux обычно используют Provider и подключение к store через хуки (useSelector, useDispatch) или через HOC connect. Это снижает необходимость пробрасывать пропсы через многие уровни.

Вопрос: Какие подходы есть к нормализации данных в Redux store? Ответ: Часто используется библиотека normalizr, которая преобразует вложенные структуры в «плоские» с помощью словарей (entities) и списков id, что облегчает обновления и выборку.

Вопрос: Как разделить store на независимые фичи/модули? Ответ: Через combineReducers или createSlice, помещая каждую фичу в свой редьюсер. Возможно использовать «feature-based» структуру директорий (e.g., usersSlice, postsSlice и т.д.).

Вопрос: Нужно ли всегда использовать Redux для глобального состояния? Ответ: Нет. React Context или более «лёгкие» стейт-менеджеры (Zustand, Recoil), либо просто хук useState/useReducer на уровне компонентов могут быть предпочтительнее, если состояние не слишком сложное или не требует расширенных возможностей (time travel debug, middleware).

Вопрос: Как обрабатывать «side effects» в Redux Saga (запросы, таймеры)? Ответ: Использовать эффекты (call, put, take, fork) внутри генераторов. Пример:

    function* fetchDataSaga(action) {
        try {
            const data = yield call(api.fetchData, action.payload);
            yield put({ type: 'FETCH_SUCCESS', data });
        } catch (err) {
            yield put({ type: 'FETCH_ERROR', error: err });
        }
    }

Вопрос: Как типизировать Redux store, экшены и редьюсеры в TypeScript? Ответ: Создать RootState интерфейс, AppDispatch тип, описать payload для экшенов, использовать дженерики в createSlice. Например:

    interface RootState {
        user: UserState;
        posts: PostsState;
    }

    const store = configureStore({ ... });
    type AppDispatch = typeof store.dispatch;

Вопрос: Что делать, если нужно сохранить часть стейта в localStorage? Ответ: Использовать middleware или готовые библиотеки (redux-persist). Они сериализуют нужные части состояния и сохраняют/грузят их при перезагрузке страницы.

Вопрос: Можно ли подключить несколько middleware? Как это сделать? Ответ: Да, можно, они вызываются по цепочке. В Redux Toolkit — через getDefaultMiddleware().concat(myMiddleware). В классическом Redux — через applyMiddleware(m1, m2, ...).

Вопрос: Как провести оптимизацию при множественных селекторах, которые часто вызываются? Ответ: Использовать мемоизацию (Reselect). Кроме того, разделять стейт на более мелкие ветки, чтобы избежать триггера обновлений при изменении неотносящихся к данному селектору полей.


</details>

<details>
  <summary>Раздел 5. Next.js и Server-Side Rendering (SSR)</summary>

Вопрос: Чем Next.js отличается от Create React App? Ответ: Next.js предоставляет из коробки SSR, статическую генерацию (SSG), встроенный роутинг, оптимизацию ресурсов, поддержку API routes. CRA даёт чистую клиентскую SPA с вебпаком и минимальными настройками.

Вопрос: Как работает getServerSideProps? Ответ: Функция, экспортируемая в файле страницы Next.js. Она вызывается на сервере при каждом запросе, возвращает пропы, которые будут переданы компоненту страницы. Позволяет рендерить данные динамически на сервере.

Вопрос: Что такое getStaticProps и getStaticPaths? Ответ: Используются для статической генерации (SSG).

getStaticProps: вызывается на этапе сборки, возвращает данные для статического рендера страницы.
getStaticPaths: используется при динамических маршрутах, указывает, какие пути нужно заранее сгенерировать.
Вопрос: Как в Next.js организовать «API Routes»? Ответ: В папке /pages/api можно создавать файлы, которые экспортируют (req, res) => void обработчик. Эти эндпоинты обрабатываются Node-сервером Next.js, позволяют не поднимать отдельный сервер для простых API-запросов.

Вопрос: В чём преимущество «Incremental Static Regeneration» (ISR) в Next.js? Ответ: Позволяет обновлять кэшированные страницы на уровне CDN/серверов после первоначальной генерации. Если указать revalidate, то по истечении заданного времени следующая загрузка страницы спровоцирует пересоздание контента.

Вопрос: Как добавить Layout во всё приложение Next.js? Ответ: Обычно создают компонент Layout и оборачивают каждую страницу в него. Либо используют специальный паттерн в _app.tsx, где можно проверить Component.getLayout, если каждая страница может иметь свой layout.

Вопрос: Как организовать роутинг в Next.js с динамическими параметрами? Ответ: Создавать файлы с названием [param].tsx в папке pages. Например pages/posts/[id].tsx. Дальше использовать useRouter или getStaticPaths/getServerSideProps для получения id.

Вопрос: Как используется «Image Optimization» в Next.js? Ответ: Next.js предоставляет компонент <Image>, который автоматически оптимизирует загружаемые изображения (ресайз, форматы, lazy loading). Требует настроить domains в next.config.js.

Вопрос: Можно ли использовать Redux или другие стейт-менеджеры в Next.js? Ответ: Да, можно. Часто рекомендуют оборачивать приложение в HOC _app.tsx, создавать store и обеспечивать совместимость при SSR (например, сериализуя state). Или же использовать react-query, SWR и пр.

Вопрос: Как настроить кастомный сервер в Next.js? Ответ: По умолчанию Next.js запускается на своём Node-сервере, но можно создать кастомный сервер (например, Express) и передавать запросы в next(). Это даёт гибкость, но теряются некоторые оптимизации из коробки.

</details>

<details>
  <summary>Раздел 6. Оптимизация производительности (Performance)</summary>

Вопрос: Чем полезен инструмент Lighthouse? Ответ: Lighthouse (встроен в Chrome DevTools) измеряет ключевые метрики производительности (FCP, LCP, TTI, CLS), проверяет доступность, SEO и «best practices». Даёт отчёт с рекомендациями.

Вопрос: Что означает метрика «Time to Interactive» (TTI)? Ответ: TTI — время, за которое страница становится «интерактивной» (браузер прорендерил контент, скрипты готовы к приёму пользовательских действий). Высокий TTI — признак «тяжёлой» страницы.

Вопрос: Что такое «Code Splitting»? Ответ: Техника разделения кода на чанки, которые загружаются по мере необходимости (динамический импорт, lazy loading). Уменьшает стартовый бандл, ускоряя первую загрузку.

Вопрос: Как работает «Preload» и «Prefetch»? Ответ:

`<link rel="preload" ...>` подгружает ресурс (шрифт, скрипт) заранее, но блокирующим образом.
`<link rel="prefetch" ...>` подгружает ресурс, пока браузер свободен, для будущих переходов (низкий приоритет).
Вопрос: Что делать с большими изображениями? Ответ: Использовать сжатие, правильные форматы (WebP/AVIF), responsive images (srcset, sizes), lazy loading, CDN.

Вопрос: Как уменьшить «Reflows/Repaints» при анимациях? Ответ: Использовать свойства, не влияющие на layout, например transform и opacity. Анимации на top, left, height заставляют браузер перекомпоновывать элементы.

Вопрос: Как использовать «web workers» для тяжёлых вычислений? Ответ: Перенести вычислительную нагрузку в worker. Пример: const worker = new Worker('worker.js');. Всё взаимодействие идёт через постинг сообщений (postMessage, onmessage). Это разгружает основной поток.

Вопрос: Как проверить, что код подгружается оптимально? Ответ: Анализировать network waterfall в DevTools, смотреть какие файлы загружаются, в каком порядке, использовать bundle analyzer (Webpack Bundle Analyzer) для просмотра размеров модулей.

Вопрос: Зачем нужна минификация и tree shaking? Ответ: Минификация удаляет пробелы, сокращает названия переменных и т.п. Tree shaking убирает неиспользуемый код. В результате уменьшается размер бандла, ускоряется загрузка.

Вопрос: Как решить проблему «Long Tasks» при анализе производительности? Ответ: Разбить большие задачи на более мелкие, использовать асинхронность (timeouts, requestIdleCallback, web workers), оптимизировать рендеринг, чтобы основной поток часто освобождался.

Вопрос: Что такое «HTTP/2 push» и актуален ли он сейчас? Ответ: HTTP/2 push позволяет серверу отправлять ресурсы до того, как клиент запросит их. На практике он мало где эффективно применяется и часто заменяется механизмами preload/prefetch. HTTP/3 (QUIC) и улучшенные CDN стратегии также влияют на его релевантность.

Вопрос: Как работает «lazy loading» для компонентов React? Ответ: Использовать React.lazy(() => import('./MyComponent')) и Suspense, чтобы подгрузка кода шла только при первом рендере компонента, уменьшая стартовый бандл.

Вопрос: Что такое «Idle Until Urgent» паттерн? Ответ: Отложенная загрузка или выполнение кода, пока пользователь не сделает действие, требующее этот код. Используется requestIdleCallback, prefetch. Задача — не нагружать главный поток лишними задачами, пока пользователь бездействует.

Вопрос: Как снизить количество HTTP-запросов? Ответ: Использовать CDN, объединять файлы (хотя в HTTP/2 это уже не так критично), спрайты для изображений, inline-ресурсы (SVG). Но с появлением HTTP/2/3 объединение файлов — не единственное решение.

Вопрос: В чём суть оптимизации критического пути рендеринга? Ответ: Сократить объем данных, необходимых для первого отображения контента (critical CSS, минимизировать JS), чтобы браузер быстрее отобразил полезный контент. Задержки в загрузке важных ресурсов откладывают видимое отображение сайта.

</details>

<details>
  <summary>Раздел 7. Тестирование (Unit, Integration, E2E)</summary>

Вопрос: Чем отличаются юнит-тесты от интеграционных и E2E-тестов? Ответ:

Unit: тестирует отдельную функцию/модуль/компонент в изоляции.
Integration: проверяет связку нескольких модулей вместе.
E2E: эмулирует поведение реального пользователя, тестирует всю систему целиком.
Вопрос: Почему Jest так популярен в React-среде? Ответ: Jest прост в настройке, имеет встроенный мокинг, снапшот-тесты, хорошо интегрируется с Babel и TypeScript. Разработан Facebook, активно поддерживается сообществом.

Вопрос: Что такое «snapshot testing» в React? Ответ: Фиксация (снимок) результата рендера компонента в виде JSON-структуры. При последующих тестах сравнивается текущий вывод с сохранённым снимком. Удобно для слежения за непреднамеренными изменениями в UI.

Вопрос: Как тестировать асинхронный код в Jest? Ответ: Использовать async/await в тестах или done() коллбэк. Важно возвращать промис или использовать await для корректного ожидания. Пример:

    test('fetch data', async () => {
    const data = await fetchData();
    expect(data).toBeTruthy();
    });

Вопрос: Чем полезен React Testing Library (RTL) по сравнению с Enzyme? Ответ: RTL ориентируется на тестирование через реальное поведение пользователя (DOM, доступность), избегая тестирования внутренних реализаций. Enzyme позволяет глубже проникать в структуру компонента, но может поощрять «бrittle tests».

Вопрос: Как тестировать «hooks» отдельно? Ответ: Использовать @testing-library/react-hooks (старая библиотека) или renderHook (вынесено в React Testing Library), позволяющее вызывать хуки в тестовой среде и проверять результаты.

Вопрос: Что такое «coverage» (покрытие тестами)? Ответ: Мера, показывающая, какая часть кода была «пройдена» во время выполнения тестов (строки, ветви, функции). Полное покрытие не гарантирует отсутствие ошибок, но помогает найти не протестированные участки логики.

Вопрос: Какие библиотеки используют для E2E-тестирования фронтенда? Ответ: Cypress, Playwright, Selenium (WebDriver), Puppeteer (headless Chrome). Cypress и Playwright — наиболее популярные и современные решения.

Вопрос: Как организовать «mocking» HTTP-запросов в тестах? Ответ: Через инструменты, позволяющие перехватывать запросы (например, nock для Node, msw — Mock Service Worker, встроенные возможности Jest fetch mock и т.д.). Это позволяет тестировать код без реальных сетевых вызовов.

Вопрос: Нужно ли писать тесты для стилизованных компонентов (CSS-in-JS)? Ответ: Обычно проверяют, что компонент рендерится и имеет определённые классы или стили. Тонкости визуального оформления часто оставляют на визуальное/мануальное тестирование, либо snapshot-тесты.

Вопрос: Чем интеграционные тесты отличаются от E2E в фронтенде? Ответ: Интеграционные могут работать в рамках одного приложения, проверяя связку нескольких компонентов или модулей. E2E идёт «снаружи», часто в браузере, эмулируя действия пользователя, задействуя все слои (frontend + backend).

Вопрос: Как тестировать компоненты, зависящие от контекста (React Context)? Ответ: Оборачивать компонент в соответствующий Provider с тестовым значением контекста. Так можно тестировать логику, зависящую от контекста.

Вопрос: Что такое «visual regression testing»? Ответ: Автоматизированное сравнение скриншотов UI между текущей и эталонной версией. Инструменты (BackstopJS, Percy) позволяют обнаружить визуальные расхождения (пиксель-перфект).

Вопрос: Как протестировать performance? Ответ: Использовать Lighthouse в CI, инструменты вроде WebPageTest, Sitespeed.io. Можно проверять TTFB, FCP, LCP, CLS, TTI и сравнивать с предыдущими сборками.

Вопрос: Можно ли использовать Jest для E2E тестирования? Ответ: Теоретически — да, с дополнительными библиотеками (например, jest-puppeteer). Но более удобно применять специализированные инструменты (Cypress, Playwright). Jest больше ориентирован на юнит и интеграцию.

</details>

<details>
  <summary>Раздел 8. DevOps и CI/CD аспекты во фронтенде</summary>

Вопрос: Как настроить автоматический деплой фронтенд-приложения? Ответ: Использовать CI/CD-платформы (GitHub Actions, GitLab CI, Jenkins и т.п.). Скрипты в pipeline обычно: установка зависимостей, сборка приложения, прогон тестов, деплой на нужный сервер или в облако.

Вопрос: Что такое «Docker multi-stage builds» и зачем они нужны фронтенду? Ответ: Multi-stage builds позволяют в одном Dockerfile сначала собрать приложение (Node, npm install, build), а затем скопировать результат в минимальный образ (Nginx для статики). Это уменьшает размер финального образа.

Вопрос: Как организовать окружения (development, staging, production) для фронтенд-приложения? Ответ: Использовать переменные окружения (ENV). Скажем, REACT_APP_API_URL для dev/staging/prod. Инжектировать их в процессе сборки или запускать разные конфигурации. Next.js предлагает .env.* файлы.

Вопрос: Чем полезны инструменты мониторинга (Sentry, Datadog) на фронтенде? Ответ: Собирать и анализировать ошибки, перформанс-метрики, трейсинг. Можно обнаружить и локализовать проблему (например, JS-ошибку в конкретном браузере), отслеживать «время отклика» и другие метрики в продакшене.

Вопрос: Как настроить zero-downtime deployment для SPA? Ответ: Использовать подходы Blue-Green, Canary или Rolling updates, когда новая версия выкатывается параллельно со старой. CDN может переключить трафик после успешной проверки. В итоге пользователь не замечает перебоев.

Вопрос: Что такое «feature flags» и как их использовать во фронтенде? Ответ: Feature flags (или toggles) позволяют включать/выключать фичи без деплоя нового кода. Можно использовать сервисы (LaunchDarkly), или собственную реализацию, управляя флагами через конфиги/бэкенд.

Вопрос: Как проверять безопасность зависимостей (npm audit, Dependabot и т.д.)? Ответ: npm audit сканирует зависимости на известные уязвимости. Dependabot (GitHub) автоматически создаёт Pull Request с обновлёнными версиями пакетов, если найдена уязвимость.

Вопрос: Как фронтенд-разработчику управлять секретами (API Keys, tokens) в репозитории? Ответ: Не хранить в репозитории в открытом виде. Использовать переменные окружения, шифрованные секреты в CI/CD (GitHub Secrets). Для действительно приватных ключей (пароли) — на сервере или в Vault.

Вопрос: Как работает кеширование в CDN (пример: Cloudflare) для SPA? Ответ: Обычно страница (index.html) может иметь короткий TTL, а статика (JS, CSS, шрифты) — длинный. При обновлении версии файлам даются новые хэширующие имена (cache busting), поэтому их можно кешировать надолго.

Вопрос: Что такое «Infrastructure as Code» (IaC) в контексте фронтенда? Ответ: Описание инфраструктуры (серверов, сети, DNS, CDN) в коде (Terraform, AWS CloudFormation). Фронтенд может тоже развёртываться через такие скрипты, обеспечивая воспроизводимость окружения.

</details>

<details>
  <summary>Раздел 9. Архитектура и продвинутые концепции</summary>

Вопрос: Что такое «Micro Frontends» и когда это имеет смысл? Ответ: Разбиение больших проектов на несколько независимых фронтенд-модулей, каждый со своим репозиторием и жизненным циклом. Имеет смысл в крупных организациях с множеством команд, когда нужна независимость релизов, но добавляет сложность в интеграции.

Вопрос: Каким образом организовать архитектуру «Monorepo» для фронтенд-проектов? Ответ: Использовать инструменты вроде Yarn Workspaces, Lerna, Nx, Turborepo. В монорепо можно хранить несколько пакетов (UI-библиотеку, сервисные утилиты), которые переиспользуются в разных приложениях.

Вопрос: Что такое «DDD» (Domain-Driven Design) и применяется ли оно во фронтенде? Ответ: DDD — методология проектирования, фокусирующаяся на предметной области и моделировании бизнес-логики. Во фронтенде DDD встречается реже, но принципы (bounded context, ubiquitous language) могут помочь при сложном бизнес-логике.

Вопрос: Как применяются «SOLID» принципы в React/TypeScript проектах? Ответ:

Single Responsibility: каждый компонент/функция выполняет одну задачу.
Open/Closed: компоненты и утилиты легко расширяются без изменения их исходного кода.
Liskov Substitution: заменять подтипы без нарушения логики (актуально для интерфейсов TS).
Interface Segregation: разбивать интерфейсы на небольшие, специфичные.
Dependency Inversion: высокоуровневые модули не зависят от конкретных реализаций низкоуровневых.
Вопрос: Чем полезна «чистая архитектура» (clean architecture) во фронтенде? Ответ: Разделение бизнес-логики (use cases), интерфейсов (controllers/presenters), фреймворка (React) и внешних источников (API). Это улучшает тестируемость, переносимость и понимание кода.

Вопрос: Что такое «BFF» (Backend for Frontend)? Ответ: Шаблон, когда создаётся специальный слой бэкенда, адаптированный под нужды конкретного фронтенда (SPA, мобильное приложение). Позволяет объединить несколько микросервисов в единый API для UI, упрощая клиентскую логику.

Вопрос: Как связаны GraphQL и React/TypeScript? Ответ: GraphQL даёт схему и типы данных. В TypeScript можно генерировать типы из схемы (например, codegen). В React используется Apollo/urql для работы с GraphQL-запросами, что позволяет строго типизировать ответы и мутации.

Вопрос: Что такое «Event Sourcing» и «CQRS»? Имеют ли они применение на фронтенде? Ответ: Event Sourcing — хранение состояния как журнала событий, CQRS — разделение команд (изменение состояния) и запросов (чтение) на разные модели. Применяются чаще на бэкенде, во фронтенде иногда используют подобные принципы в сложных системах (Redux — отдалённое подобие).

Вопрос: Когда стоит использовать WebSockets, а когда — SSE (Server-Sent Events)? Ответ:

WebSocket: нужен двунаправленный канал (чат, онлайн-игры).
SSE: когда сервер рассылает события клиентам (новостные ленты, уведомления), и клиент не отправляет много обратных запросов.
Вопрос: Зачем нужен «domain-driven forms» подход? Ответ: Формы описываются не только как набор инпутов, но как часть бизнес-домена. Это облегчает валидацию, интеграцию с моделью данных, переиспользование логики в разных UI.

Вопрос: Как планировать архитектуру, если в будущем приложение вырастет? Ответ: Заранее закладывать модульную структуру, разделение ответственности, возможность масштабирования (слабая связность, ясные интерфейсы). Могут помочь паттерны Micro Frontends, Monorepo, гибкие CI/CD pipeline.

Вопрос: Как структурировать «feature-based» фронтенд-проект? Ответ: Группировать код по функциональным модулям (features): компоненты, редьюсеры, селекторы, стили в одной папке. Это упрощает поиск, рефакторинг и повторное использование.

Вопрос: Когда лучше использовать REST, а когда GraphQL? Ответ:

REST: проще, когда нет сложных связей, и у API стабильная структура. Легко кэшировать, подходит в большинстве случаев.
GraphQL: даёт гибкость выборки данных, уменьшает «overfetching/underfetching» при сложных отношениях в сущностях. Но требует более сложной настройки сервера и schema management.
Вопрос: Как обеспечить «Backward Compatibility» во фронтенд-приложениях? Ответ: Использовать версионирование API (v1, v2), поддерживать старые версии компонентов/endpoint’ов, иметь фиче-флаги. Если браузеры не поддерживают определённые функции, применять полифилы/транспил.

Вопрос: Что такое «Progressive Enhancement» и почему это иногда важно? Ответ: Подход к разработке, при котором базовая функциональность сайта работает даже без JS (или без современных возможностей), а дополнительные улучшения включаются, если браузер их поддерживает. Помогает с доступностью и совместимостью.

</details>

<details>
  <summary>Раздел 10. Безопасность и сетевые аспекты</summary>

Вопрос: В чём разница между XSS и CSRF? Ответ:

XSS (Cross-Site Scripting) — внедрение произвольного JavaScript кода в сайт через уязвимые поля, скрипты.
CSRF (Cross-Site Request Forgery) — использование сессии пользователя для отправки нежелательных запросов от его имени.
Вопрос: Как защититься от XSS? Ответ: Экранировать (sanitize) пользовательский ввод, использовать правильные заголовки (Content-Security-Policy), не использовать неочищенный dangerouslySetInnerHTML в React без крайней необходимости.

Вопрос: Что такое «Content Security Policy» (CSP)? Ответ: HTTP-заголовок, позволяющий ограничить источники скриптов, стилей, изображений. Например, default-src 'self'; script-src 'self' https://trusted.cdn.com;. Уменьшает вероятность XSS.

Вопрос: Как хранить JWT-токены на клиенте? Ответ: Можно хранить в HttpOnly cookie (более безопасно против XSS), или в localStorage/sessionStorage (простая реализация, но уязвима для XSS). Нужно понимать риски и защитные меры (CORS, CSRF-токены).

Вопрос: Что такое «SameSite cookies»? Ответ: Атрибут куки, ограничивающий отправку куки только при запросах с того же сайта. SameSite=Strict не отправляет куки при переходе с внешних ресурсов. SameSite=Lax более либеральный, но всё же защищает от некоторых CSRF-атак.

Вопрос: Зачем нужен HTTPS и чем опасен HTTP без SSL? Ответ: HTTPS шифрует трафик, защищая от перехвата данных, MITM-атак. HTTP без шифрования легко уязвим: злоумышленники могут просматривать или модифицировать передаваемые данные.

Вопрос: Как работает CORS (Cross-Origin Resource Sharing)? Ответ: CORS с помощью заголовков (Access-Control-Allow-Origin, Access-Control-Allow-Methods, Access-Control-Allow-Headers) определяет, какие домены могут отправлять запросы к серверу и какие заголовки разрешены. Нужно настроить на сервере.

Вопрос: Чем опасно использовать eval в JavaScript? Ответ: Открывает дверь XSS-атакам, может выполнить произвольный код, сложно оптимизируется движком JS. Почти всегда есть более безопасные альтернативы.

Вопрос: Что такое «clickjacking» и как защититься? Ответ: Clickjacking — когда злоумышленник оборачивает сайт в iframe и незаметно манипулирует кликами пользователя. Защита — заголовок X-Frame-Options: DENY или SAMEORIGIN или frame-ancestors в CSP.

Вопрос: Что такое «SQL/NoSQL Injection» и насколько это касается фронтенда? Ответ: Injection-атаки касаются в первую очередь сервера. Но если фронтенд позволяет отправлять «грязные» данные (без валидации/санитизации) и сервер не защищён, может произойти Injection. Во фронтенде важно не доверять пользовательскому вводу и передавать его безопасно.

</details>

<details>
  <summary>Раздел 11. Работа с различными API и протоколами</summary>

Вопрос: Что такое «HTTP/3» (QUIC) и какие выгоды даёт фронтенду? Ответ: HTTP/3 работает поверх протокола QUIC (UDP), обеспечивая более быструю и надёжную доставку пакетов, улучшение при пакетной потере. Для фронтенда это может ускорить загрузку ресурсов и снизить латентность.

Вопрос: Как работает «Service Worker» и зачем он нужен? Ответ: Service Worker — скрипт, работающий в фоновом процессе браузера, перехватывающий сетевые запросы. Может кэшировать ресурсы, обеспечивать офлайн-режим, пуш-уведомления. Основной элемент PWA.

Вопрос: Чем отличается Push API от WebSockets? Ответ: Push API (Notification API) — канал, где сервер может отправить пуш-уведомление, браузер покажет их, даже если вкладка не активна. WebSockets — постоянное двустороннее соединение между клиентом и сервером, подходит для обмена данными в реальном времени.

Вопрос: Что такое GraphQL Subscriptions? Ответ: Механизм, позволяющий клиенту подписаться на обновления в реальном времени через GraphQL. Обычно реализуется на базе WebSockets (Apollo Subscriptions), когда сервер шлёт события при изменении данных.

Вопрос: Каков принцип RESTful API? Ответ: Использование ресурсов (URL), методов (GET, POST, PUT, DELETE), возвращение соответствующих статусов (2xx, 4xx, 5xx), HATEOAS (опционально). Архитектурный стиль, где каждая сущность — ресурс, который можно CRUD-оперировать.

Вопрос: Как работать с бинарными данными (ArrayBuffer, Blob) на фронтенде? Ответ: Использовать fetch с responseType: "arrayBuffer", либо XMLHttpRequest. Затем преобразовывать полученный ArrayBuffer в Blob, либо напрямую отображать (например, в <img src=... blob-url>).

Вопрос: Что такое «SSE» (Server-Sent Events)? Ответ: Механизм, где сервер может отправлять односторонние события клиенту, используя EventSource. Удобно для простых реалтайм-уведомлений. Клиент не может отправлять сообщения обратно через SSE.

Вопрос: Зачем и как использовать «AbortController»? Ответ: Позволяет отменять fetch-запросы или другие асинхронные операции. Создаётся new AbortController(), передаётся signal в fetch, при controller.abort() fetch выбрасывает ошибку типа AbortError.

Вопрос: Как загрузить файлы на сервер и отслеживать прогресс? Ответ: Использовать FormData или прямой AJAX (XMLHttpRequest) с onprogress или fetch+ProgressEvent (пока ограничено). В React часто применяют библиотеки (axios с прогресс-коллбэком).

Вопрос: Что такое «multipart/form-data»? Ответ: Формат передачи данных при отправке форм с файлами. Данные разбиваются на части, каждая часть может содержать файл или поле. Используется <form enctype="multipart/form-data" ...> или FormData в JS.

</details>

<details>
  <summary>Раздел 12. CSS, стили и верстка на продвинутом уровне</summary>

Вопрос: Как работают CSS-переменные (custom properties) и чем отличаются от препроцессорных переменных (Sass, Less)? Ответ: CSS-переменные (например, --my-color: red;) живут в DOM, меняются динамически, наследуются, работают в рантайме. Переменные Sass/Less компилируются на этапе сборки и недоступны в реальном времени.

Вопрос: Что такое «CSS Modules» и как они помогают? Ответ: CSS Modules генерируют уникальные классы на основе локального файла, исключая конфликты имён. В итоге, импортируя стили в React-компонент, вы получаете объект с уникальными именами классов.

Вопрос: Чем хорош подход «BEM» (Block, Element, Modifier)? Ответ: Строгая методология именования классов (например, .block__element--modifier). Упрощает масштабируемость и читаемость стилей, снижает конфликты классов.

Вопрос: Как добиться адаптивности (responsive) без большого числа медиа-запросов? Ответ: Использовать «fluid layout» (flex, grid), проценты, viewport-based единицы (vw, vh), CSS clamp. Например, clamp(1rem, 2vw, 2rem).

Вопрос: В чём отличия CSS Grid и Flexbox? Ответ: Flexbox — одномерная модель (по строке или столбцу). Grid — двумерная (строки и столбцы одновременно). Grid даёт мощные инструменты выравнивания и автоматической раскладки.

Вопрос: Как реализовать «dark theme» или «theme switch»? Ответ: Применять CSS-переменные и переключать их значения (через JavaScript или prefers-color-scheme media query). Либо использовать разные классы (например, .theme-dark .component { ... }).

Вопрос: Что такое «Critical CSS»? Ответ: Выделение стилей, необходимых для рендера видимой части страницы (above-the-fold), и их инлайн-вставка в <head>. Остальные стили загружаются асинхронно. Это снижает время до первого рендера.

Вопрос: Как бороться с «Cumulative Layout Shift» (CLS)? Ответ: Заранее резервировать пространство для изображений, объявлять размеры (width/height), использовать font-display для шрифтов, не вставлять динамический контент в начале страницы без фиксированных размеров.

Вопрос: Что такое «PostCSS» и какие задачи решает? Ответ: PostCSS — платформа плагинов для трансформации CSS (autoprefixer, nested, cssnano). Можно добавлять новые синтаксические возможности (e.g., cssnext) и оптимизировать финальный CSS.

Вопрос: Что такое «Container Queries»? Ответ: Новая возможность CSS (ещё в процессе стандартизации), позволяющая менять стили на основе размеров контейнера, а не только вьюпорта. Это упрощает создание более модульных, реактивных компонентов.

</details>

<details>
  <summary>Раздел 13. Mobile и PWA</summary>

Вопрос: Что такое PWA и какие основные критерии? Ответ: PWA (Progressive Web App) — веб-приложение с возможностями: офлайн-режим, push-уведомления, иконка на главном экране, установка как приложение. Требует HTTPS, service worker и web app manifest.

Вопрос: Как реализовать офлайн-режим в PWA? Ответ: Использовать Service Worker для кэширования необходимых файлов (HTML, CSS, JS, данные). При отсутствии сети запросы могут возвращать кэшированные ресурсы.

Вопрос: Зачем нужен «web app manifest»? Ответ: Файл manifest.json описывает иконки, имя, цвет темы и другие параметры приложения. Позволяет «установить» веб-приложение на домашний экран мобильного устройства.

Вопрос: Как тестировать PWA? Ответ: Lighthouse может проверить PWA-особенности (иконки, offline, HTTPS). Также вручную проверять установку на мобильные устройства, работоспособность offline, пуш-уведомления.

Вопрос: Что такое «Cordova», «Capacitor», «React Native Web»? Ответ:

Cordova/Capacitor — обёртки над веб-приложением, позволяющие паковать его как нативное мобильное приложение, с доступом к API устройств (камера и т.д.).
React Native Web — писать React Native-компоненты, которые могут работать и в браузере, и в мобильном приложении с одним кодом, насколько это возможно.
Вопрос: Как адаптировать верстку под мобильные устройства? Ответ: Использовать responsive design, медиа-запросы, flexible layouts, touch-friendly элементы (большие кнопки, достаточные отступы). Тестировать в Chrome DevTools Device Mode, на реальных девайсах.

Вопрос: Можно ли работать со встроенными датчиками (GPS, giroscop) в веб-приложениях? Ответ: Да, есть API типа Geolocation, DeviceOrientation, но они имеют ограничения (HTTPS, user permission). Для продвинутых возможностей иногда нужен натив (через Cordova/Capacitor).

Вопрос: Как организовать push-уведомления в PWA? Ответ: Использовать Push API + Service Worker. Сервер отправляет push-сообщения, браузер показывает уведомления даже при закрытом веб-приложении, если пользователь дал разрешение.

Вопрос: Что такое «Add to Home Screen» баннер? Ответ: Механизм в мобильных браузерах, предлагающий пользователю установить PWA на домашний экран. Появляется, если PWA соответствует определённым критериям (HTTPS, манифест, иконки).

Вопрос: Как настроить fallback на случай, когда пользователь офлайн, а ресурс не закэширован? Ответ: В Service Worker перехватывать запрос и, если ресурс не найден в кэше, отдавать специальную «offline» страницу. Туда можно встроить функциональность, уведомляющую пользователя о недоступности сети.

</details>

<details>
  <summary>Раздел 14. Прочие вопросы, best practices, soft skills</summary>

Вопрос: Что такое «интернационализация» (i18n) и «локализация» (l10n)? Ответ:

i18n — подготовка приложения к поддержке нескольких языков и регионов (замена строк, форматов дат).
l10n — процесс перевода и адаптации под конкретный язык и культуру.
Вопрос: Как работать с датами/временем, учитывая часовые пояса и локализацию? Ответ: Использовать библиотеки (date-fns, Luxon, Moment) или Intl.DateTimeFormat. Хранить дату в UTC, преобразовывать только при отображении. Учитывать настройки пользователя.

Вопрос: Что такое «feature toggle» (или «feature flag»), и как это помогает в agile-разработке? Ответ: Позволяет выпускать код с отключённой фичей, чтобы постепенно включать и тестировать её (A/B-тесты), не дожидаясь отдельного релиза. Уменьшает риск, улучшает непрерывную интеграцию.

Вопрос: Как проводить код-ревью эффективно? Ответ: Смотреть не только на стиль кода, но и на архитектуру, потенциальные баги, читаемость. Делать ревью небольших пул-реквестов, давать конструктивную обратную связь. Не забывать о позитиве.

Вопрос: Когда стоит внедрять линтеры и форматтеры (ESLint, Prettier)? Ответ: С самого начала проекта. Это обеспечивает единообразие стиля, избегание ошибок. Можно настроить pre-commit hooks (husky) для автозапуска линтера/тестов.

Вопрос: Что такое «Atomic Design»? Ответ: Методология проектирования интерфейсов, где UI разбивается на атомы (кнопки, инпуты), молекулы (сочетания атомов), организмы (сложные блоки), шаблоны и страницы. Помогает структурировать дизайн-систему.

Вопрос: Почему важна «accessibility» (A11y) и какие инструменты для проверки есть? Ответ: Доступность позволяет людям с ограниченными возможностями пользоваться сайтом (скринридеры, клавиатурная навигация). Инструменты: Lighthouse, axe, WAVE, NVDA/VoiceOver для практической проверки.

Вопрос: Чем полезна Storybook? Ответ: Позволяет разрабатывать и демонстрировать UI-компоненты в изоляции, тестировать различные состояния без запуска всего приложения. Ускоряет разработку и упрощает дизайн-систему.

Вопрос: Что такое «Cognitive Load» в UI/UX, и как его уменьшить? Ответ: Когнитивная нагрузка — насколько сложно пользователю понять и использовать интерфейс. Уменьшают путём упрощения навигации, лаконичного дизайна, чёткого визуального и смыслового разделения, подсказок.

Вопрос: Как организовать документирование компонентов (UI-кит)? Ответ: Использовать Storybook, Ladle или похожие инструменты. Описывать пропсы, варианты использования, добавлять примеры кода, соблюдать общий гайдлайн по стилям.

Вопрос: Что делать, если есть конфликт между дизайном и технической реализацией? Ответ: Обсудить с дизайнером, предложить компромисс, оценить трудоёмкость, объяснить ограничения. Цель — найти решение, которое удовлетворит бизнес-требования и не поставит проект на паузу из-за избыточной сложности.

Вопрос: Как планировать задачи в Scrum / Kanban? Ответ: Scrum предполагает спринты, планирование на фиксированные промежутки. Kanban — непрерывный поток задач, ограничение Work In Progress (WIP). Важно декомпозировать задачи, расставлять приоритеты.

Вопрос: Почему важно использовать Git Branching Workflow (GitFlow, GitHub Flow)? Ответ: Упрощает параллельную разработку, код-ревью, выпуск релизов. Даёт структуру (feature-ветки, release-ветки, hotfix). Помогает избежать конфликтов в основном коде.

Вопрос: Как внедрять новые библиотеки в проект, чтобы не сломать всё? Ответ: Создать ветку, добавить библиотеку, протестировать в локальной среде, написать тесты, провести код-ревью. Возможно, развернуть на тестовом окружении (staging) и проверить, нет ли конфликтов.

Вопрос: Что такое «pair programming» и как это помогает? Ответ: Два разработчика работают за одним компьютером (или через экран) над одной задачей. Ускоряет обмен знаниями, снижает число ошибок. Важно, чтобы роли «driver»/«observer» чередовались.

Вопрос: Как справляться с «legacy code»? Ответ: Постепенный рефакторинг (боязнь трогать всё сразу). Писать тесты перед изменениями (Approval tests, snapshot), использовать «страховочные» инструменты (линетры, типизация), выстраивать план поэтапного улучшения.

Вопрос: Что такое «refactoring sprints»? Ответ: Время, специально отведённое в плане разработки на улучшение структуры кода, оптимизацию, оплату «технического долга». Помогает поддерживать проект в здоровом состоянии.

Вопрос: Зачем нужны различные ветки окружения (dev, test, stage, prod) при деплое? Ответ: Позволяют проверять фичи в разных средах, тестировать интеграции и стабильность. «prod» — стабильная рабочая версия, «stage» — максимально приближенная к боевым условиям, «dev» — для активной разработки.

Вопрос: Как вести себя, если в код-ревью обнаружена ошибка коллеги? Ответ: Корректно указывать на проблему, объяснять возможные последствия, предлагать пути решения. Стараться быть конструктивным, не переходить на личности.

Вопрос: Что важнее для Middle/Middle+ разработчика: широкий кругозор в технологиях или глубокое понимание основных инструментов? Ответ: Баланс. Нужно уверенно владеть основным стеком (React, TS, экосистема) и быть готовым к изучению нового при необходимости. Глубина в ключевых областях даёт прочный фундамент, но следует иметь общее представление о тенденциях и смежных технологиях.

</details>

## Around front-end.   Middle / middle + (gpt)

<details>
  <summary>Блок 1. Основы веб-разработки (HTML, сетевые аспекты, общие концепции)</summary>

Вопрос: Что происходит в браузере, когда пользователь вводит URL и нажимает Enter?
Ответ:

Браузер разбирает URL (протокол, домен, путь).
Выполняется DNS-запрос для определения IP-адреса.
Устанавливается TCP-соединение с сервером, затем HTTPS/HTTP.
Отправляется HTTP-запрос, сервер обрабатывает, возвращает ответ.
Браузер получает HTML, начинает парсинг, запрашивает связанные ресурсы (CSS, JS, изображения).
Рендерит страницу.

Вопрос: Что такое HTTP и чем он отличается от HTTPS?
Ответ:

    HTTP — протокол передачи гипертекста, данные идут без шифрования.
    HTTPS — то же самое, но поверх TLS/SSL-шифрования. Обеспечивает конфиденциальность и целостность при передаче данных.

Вопрос: Какие методы HTTP-запросов вы знаете и для чего они используются?
Ответ: Основные:

    GET — получить ресурс.
    POST — создать ресурс или отправить данные на сервер.
    PUT — полностью обновить/заменить существующий ресурс.
    PATCH — частичное обновление ресурса.
    DELETE — удалить ресурс.
Вопрос: В чем разница между 200 OK, 301 Moved Permanently, 404 Not Found и 500 Internal Server Error?
Ответ:

    200 OK — запрос успешен, возвращен ответ.
    301 — ресурс навсегда перемещён по новому URL (редирект).
    404 — ресурс не найден на сервере.
    500 — внутренняя ошибка сервера (что-то пошло не так на стороне сервера).

Вопрос: Что такое «кэширование» на уровне HTTP?
Ответ: Механизм хранения копии ресурса (HTML, CSS, JS, изображения) в браузере или на прокси-сервере для ускорения повторного запроса. Управляется заголовками (Cache-Control, ETag, Last-Modified, Expires).

Вопрос: Что значит «статический» и «динамический» контент?
Ответ:

Статический контент: неизменяемые файлы (HTML, картинки, стили), которые отдаются «как есть» с сервера.
Динамический контент: формируется в реальном времени (например, используя шаблонизатор или данные из БД), может меняться в зависимости от запроса.

Вопрос: Зачем нужен DOCTYPE в HTML?
Ответ: Указывает браузеру, что документ соответствует определенной версии HTML. Используем <!DOCTYPE html> для HTML5, чтобы включать стандартный режим (standards mode) рендеринга.

Вопрос: В чем разница между `<script>` с атрибутами defer и async?
Ответ:

    async — скрипт загружается параллельно с HTML, выполняется сразу по готовности, может прервать парсинг.
    defer — скрипт загружается параллельно, но выполнение откладывается до окончания парсинга HTML.

Вопрос: Что такое «семантическая верстка»?
Ответ: Использование HTML-тегов по их смыслу (header, nav, main, article, section и т.д.) для улучшения доступности и SEO. Семантические теги описывают структуру содержимого, а не внешний вид.

Вопрос: Для чего нужны метатеги (<meta>) в HTML?
Ответ: Хранят метаинформацию о документе: кодировку (charset), описание, ключевые слова (SEO), viewport (для адаптивной верстки), авторство и т.д.

Вопрос: Что такое «Viewport» и как правильно его настроить?
Ответ: Viewport — это область, в которой браузер отрисовывает страницу (особенно важно на мобильных устройствах). Настройка через <meta name="viewport" content="width=device-width, initial-scale=1.0"> помогает адаптивному дизайну.

Вопрос: Что такое Progressive Enhancement и Graceful Degradation?
Ответ:

    Progressive Enhancement: сначала базовый функционал для всех браузеров, а затем улучшения для современных (JS, CSS-фичи и т.д.).
    Graceful Degradation: строим полную версию для современных браузеров, при этом в старых браузерах часть функционала может деградировать, но базовые возможности остаются.

Вопрос: Что такое «Favicon»?
Ответ: Иконка веб-сайта, отображаемая в вкладке браузера, в закладках. Обычно это файл favicon.ico или PNG, подключается через <link rel="icon" href="...">.

Вопрос: Как проверить корректность HTML-документа?
Ответ: Использовать валидатор (W3C HTML Validator), который проверяет синтаксис, соответствие спецификации, правильность написания тегов и атрибутов.

Вопрос: Что такое «атрибут lang» в HTML и почему он важен?
Ответ: Указывает язык содержимого документа (<html lang="ru">). Это важно для accessibility (экранные читалки) и для поисковых систем.

Вопрос: Какие инструменты (DevTools) есть в современных браузерах для отладки HTML/CSS/JS?
Ответ: Все популярные браузеры (Chrome, Firefox, Edge, Safari) содержат встроенные инструменты разработчика: просмотр DOM, дерево стилей, эмулятор мобильных устройств, отладчик JS, профилировщик производительности.

Вопрос: Что такое MIME-тип?
Ответ: MIME-тип (content-type) описывает тип передаваемых данных (например, text/html, application/json, image/jpeg) при ответе сервера, чтобы браузер понимал, как интерпретировать ресурс.

Вопрос: В чем разница между HTTP-заголовками «Content-Type» и «Accept»?
Ответ:

    Content-Type — указывает, в каком формате сервер отдает ответ (например, JSON).
    Accept — указывает серверу, какой формат клиент ожидает получить.

Вопрос: Чем полезны кодировки Unicode (UTF-8) и почему их применяют?
Ответ: UTF-8 охватывает практически все символы (латиница, кириллица, иероглифы и т.д.) в единой кодировке. Это стандарт де-факто в вебе, упрощает международную и многоязычную поддержку.

Вопрос: Что такое «зеркальный DOM» (Shadow DOM)?
Ответ: Shadow DOM — механизм инкапсуляции структуры и стилей внутри веб-компонентов. CSS, HTML внутри Shadow-root не «утекают» наружу и не конфликтуют с внешним кодом.

</details>

<details>
  <summary>Блок 2. CSS и верстка</summary>

Вопрос: Что такое специфичность (Specificity) в CSS?
Ответ: Показатель «приоритета» CSS-селектора при конфликте стилей. Специфичность вычисляется по формуле: (количество ID) × 100 + (количество классов/атрибутов/псевдоклассов) × 10 + (количество тегов/псевдоэлементов).

Вопрос: Что такое «каскад» в CSS?
Ответ: Механизм, по которому «применяются» или «отменяются» разные правила к одному элементу. Учитываются специфичность, порядок подключения и использование важных правил (!important).

Вопрос: Как работает box-sizing?
Ответ:

    content-box (по умолчанию): ширина/высота учитывают только содержимое, не включая padding и border.
    border-box: ширина/высота включают и содержимое, и padding, и border.

Вопрос: Как сделать адаптивную верстку без «media queries»?
Ответ: Использовать гибкие единицы (проценты, vh, vw, minmax() в Grid), и свойства вроде flex в Flexbox. Но для более тонких перестроек по брейкпоинтам все же чаще применяют media queries.

Вопрос: Чем отличается display: none; от visibility: hidden;?
Ответ:

    display: none; полностью убирает элемент из потока, как будто его нет.
    visibility: hidden; сохраняет место под элемент, но делает его невидимым.

Вопрос: Что делает position: absolute;?
Ответ: Позволяет позиционировать элемент относительно ближайшего предка с непозиционированным static (или относительно body, если нет). Элемент «вырывается» из общего потока и может перекрывать другие.

Вопрос: Как работает Flexbox?
Ответ: Это модель лэйаута, в которой контейнер (display: flex;) управляет расположением дочерних элементов (flex items) по оси (main axis) или в обратном порядке, контролирует выравнивание, распределение пространства (justify-content, align-items и т.д.).

Вопрос: Когда лучше использовать CSS Grid, а когда — Flexbox?
Ответ:

    Grid: двумерная сетка (строки и колонки), более сложные макеты с точным позиционированием.
    Flexbox: одномерное расположение (по строке или столбцу), динамическое выравнивание, «резиновый» лэйаут.

Вопрос: Что такое «float» и в современных проектах он часто используется?
Ответ: float исторически применялся для обтекания текстом изображений и создания макетов. Сейчас для лэйаута обычно используют Flexbox/Grid. Float применяется реже — в специфических случаях (обтекание текста).

Вопрос: Как работает z-index и почему иногда не срабатывает?
Ответ: z-index работает внутри определенного контекста наложения (stacking context). Если элемент не является позиционированным (position не static) или вложен в родитель с собственным stacking context, z-index может не сработать, как ожидается.

Вопрос: Что такое «Reset CSS» или «Normalize.css» и зачем они нужны?
Ответ: Браузеры по умолчанию имеют собственные стили для тегов. Reset и Normalize приводят их к единому виду, чтобы разработчик мог лучше контролировать внешний вид верстки во всех браузерах.

Вопрос: Чем отличается rem от em?
Ответ:

    em: относительная единица, основывается на размере шрифта родителя.
    rem: относительная единица, основывается на размере шрифта корневого элемента (html). При rem масштабирование идёт относительно html { font-size: ... }.

Вопрос: Что такое «CSS-Transitions» и «CSS-Animations»?
Ответ:

    Transitions — анимации перехода при изменении свойства (hover, focus и т.п.).
    Animations — ключевые кадры (@keyframes), более сложные, могут запускаться без прямого вмешательства пользователя и повторяться.

Вопрос: Как оптимизировать анимацию в CSS?
Ответ: Анимировать в первую очередь transform и opacity, избегать анимации свойств, затрагивающих layout (width, height, margin, top, left). Это снижает reflow и улучшает производительность.

Вопрос: Что такое «responsive images»?
Ответ: Использование HTML-атрибутов srcset, sizes и <picture> для адаптации изображений под разные разрешения, плотность пикселей (Retina), или разные варианты изображений (webp, avif).

Вопрос: Для чего нужны псевдоэлементы ::before и ::after?
Ответ: Позволяют вставлять «виртуальные» элементы (например, декоративные иконки, бэйджи, стилистические блоки) без добавления реальных HTML-элементов.

Вопрос: Что такое «mixins» в препроцессорах (SASS, LESS)?
Ответ: Это фрагменты CSS-кода, которые можно переиспользовать, передавая аргументы. Ускоряют разработку, уменьшают дублирование стилей.

Вопрос: Чем полезны методологии CSS — BEM, OOCSS, SMACSS?
Ответ: Помогают структурировать CSS в больших проектах, избегать конфликтов и дублирования, делают код более понятным и поддерживаемым.

Вопрос: Как работают «CSS-модули» (CSS Modules)?
Ответ: Каждый файл .module.css компилируется в уникальный набор классов, чтобы стили были «локальными» для конкретного компонента, предотвращая конфликты имен.

Вопрос: Как определить «какую часть CSS» реально используется?
Ответ: С помощью инструментов (Chrome DevTools Coverage, PurgeCSS, UnCSS) можно анализировать, какие селекторы реально совпали с DOM на странице, а какие нет (ненужные стили).

</details>

<details>
  <summary>Блок 3. JavaScript и общие основы программирования</summary>

Вопрос: Что такое «замыкание» (closure) в JavaScript?
Ответ: Замыкание — это способность функции запоминать свое лексическое окружение (переменные), даже если эта функция выполняется вне своей исходной области видимости.

Вопрос: Для чего в JS используются функции «стрелки» (arrow functions)?
Ответ: Упрощенный синтаксис и лексическое связывание this (стрелочная функция не создает собственного this). Также нельзя использовать arguments и оператор new с arrow functions.

Вопрос: Как работает «асинхронность» в JavaScript?
Ответ: JS — однопоточный язык с Event Loop. Асинхронные операции (таймеры, сетевые запросы) ставятся в очередь, а колбэки запускаются, когда стек выполнения свободен и событие готово.

Вопрос: Что такое «типизация» в JavaScript?
Ответ: JS — динамически типизированный язык, где тип переменной определяется во время выполнения. Переменная может менять тип в ходе программы. В TypeScript/Flow, напротив, есть статическая типизация во время компиляции.

Вопрос: Как работает оператор ===?
Ответ: Это строгое сравнение, при котором не происходит приведения типов. Два значения равны, только если они одного типа и одинакового значения.

Вопрос: В чем разница между «var», «let» и «const»?
Ответ:

    var — функциональная область видимости, поднимается (hoisting).
    let — блочная область видимости, не поднимается в том виде, как var.
    const — то же, что let, но нельзя переназначать значение.

Вопрос: Как проверить, что «число является целым» в JavaScript?
Ответ: Использовать Number.isInteger(value). Ранее могли сравнивать value % 1 === 0, но это менее надежно из-за плавающей точности.

Вопрос: Что такое «NaN» и чем он особенен?
Ответ: «Not a Number» — результат некорректной математической операции. Особенность: NaN не равен ничему, даже самому себе, поэтому проверка делается через isNaN() или Number.isNaN().

Вопрос: Как реализовать каррирование (currying) в JS?
Ответ: Каррирование — преобразование функции f(a,b,c) в последовательность функций f(a)(b)(c). Делается созданием функции, которая возвращает другую функцию, «запоминая» часть аргументов.

Вопрос: Что делает оператор new?
Ответ: 1) Создает пустой объект. 2) Присваивает ему прототип функции-конструктора. 3) Вызывает конструктор в контексте этого объекта. 4) Возвращает объект (если не возвращено что-то другое).

Вопрос: Как работает «hoisting» в JavaScript?
Ответ: Объявления функций и переменных (var) «поднимаются» в начало области видимости, но при var переменная инициализируется undefined до фактического присвоения.

Вопрос: Чем отличаются forEach, map, filter и reduce?
Ответ:

    forEach: перебирает элементы, не возвращает результат.
    map: возвращает новый массив, преобразуя каждый элемент.
    filter: возвращает новый массив, отбирая те элементы, где колбэк вернул true.
    reduce: свёртка массива в одно итоговое значение (число, объект и т.д.).

Вопрос: Что такое «strict mode» ('use strict')?
Ответ: Включает более строгие правила: запрещает использовать неявное создание глобальных переменных, дублирующиеся параметры, межеуточные особенности. Помогает писать более безопасный код.

Вопрос: Как работают прототипы в JavaScript?
Ответ: Каждый объект имеет ссылку на свой `[[Prototype]]`. Если свойство не найдено в объекте, поиск идёт по цепочке прототипов. Это основа объектной модели в JS.

Вопрос: Что такое «Promise» и какие методы у него есть?
Ответ: Promise — объект, представляющий отложенную операцию. Методы:

    then(onFulfilled, onRejected) — при выполнении или отклонении.
    catch(onRejected) — обрабатывает ошибку.
    finally(onFinally) — вызывается в любом случае.

Вопрос: Как работает async/await?
Ответ: async помечает функцию асинхронной, что позволяет внутри неё использовать await, который приостанавливает исполнение, пока Promise не будет выполнен или отклонён.

Вопрос: Как отлавливать ошибки в асинхронных функциях?
Ответ: Использовать try/catch внутри async функции либо метод .catch() у Promise. Пример:

    try {
        const data = await fetchData();
    } catch (err) {
        console.error(err);
    }

Вопрос: Что такое «Event Loop» в JavaScript?
Ответ: Механизм, который обрабатывает очередь коллбэков. Состоит из стека (call stack) и очереди (callback queue + microtask queue). Когда стек пуст, берётся следующая задача из очереди.

Вопрос: Что такое «microtasks» и «macrotasks»?
Ответ:

    Microtasks: промисы, MutationObserver. Выполняются сразу после текущего стека синхронного кода, до macrotask.
    Macrotasks: setTimeout, setInterval, I/O, UI-ивенты. Обрабатываются в основном цикле событий.

Вопрос: В чём суть объекта this?
Ответ: this — ссылка на текущий контекст выполнения. В строгом режиме, если контекст не установлен явно (например, при обычном вызове функции), this будет undefined. В методах объекта this ссылается на объект.

</details>

<details>
  <summary>Блок 4. Архитектура и проектирование</summary>

Вопрос: Что такое «MVC», «MVP», «MVVM»?
Ответ: Паттерны разделения ответственностей:

    MVC (Model-View-Controller): Модель (данные), Вид (презентация), Контроллер (логика).
    MVP (Model-View-Presenter): вместо Контроллера есть Презентер, который управляет View и моделью.
    MVVM (Model-View-ViewModel): ViewModel связана с View (двухсторонняя привязка), упрощает логику.

Вопрос: Что такое «SOLID»-принципы?
Ответ:

    Single Responsibility
    Open/Closed
    Liskov Substitution
    Interface Segregation
    Dependency Inversion

Они помогают строить более поддерживаемые и гибкие приложения.

Вопрос: Что значит «DRY» и «KISS»?
Ответ:

    DRY (Don’t Repeat Yourself) — не дублировать код, выносить повторяющиеся части в функции/модули.
    KISS (Keep It Simple, Stupid) — стараться делать код/архитектуру проще, без избыточных усложнений.

Вопрос: Что такое «Monolith» и «Microservices» в бэкенде? И при чём тут фронтенд?
Ответ:

    Monolith: приложение, где все функциональные модули связаны в один сервис.
    Microservices: каждая бизнес-задача выделена в независимый сервис.
Фронтенд взаимодействует с этими архитектурами через API. При микросервисной архитектуре могут быть «BFF» (Backend for Frontend) или «Micro Frontends».

Вопрос: Каковы преимущества «чистой архитектуры» (Clean Architecture)?
Ответ: Ясное разделение слоёв (бизнес-логика, интерфейс, инфраструктура), слабая связность, повышенная тестируемость и читабельность. Легче поддерживать и развивать.

Вопрос: Что такое «Domain Driven Design» (DDD)?
Ответ: Методология, фокусирующаяся на предметной области (Domain). Выделяются bounded context, ubiquitous language, entities/aggregates. Во фронтенде DDD встречается реже, но принципы можно применять при сложной бизнес-логике.

Вопрос: Когда нужен «Design System» или «UI Kit»?
Ответ: В больших проектах для единообразия интерфейсов. Это набор компонентов, правил стилей, общих паттернов UX, позволяющий легко переиспользовать и масштабировать UI.

Вопрос: Что такое «feature-driven development» (FDD)?
Ответ: Метод, при котором функциональные модули (фичи) разрабатываются изолированно, имеют собственные каталоги, стили, тесты. Удобно при масштабировании и поддержке.

Вопрос: Что значит «stateful» и «stateless» компонент/сервис?
Ответ:

    Stateful: хранит внутреннее состояние. В контексте фронтенда — это компонент/модуль, который запоминает какие-то данные.
    Stateless: не хранит собственного состояния, все данные получает через пропсы/вызовы и отдает обратно.

Вопрос: Зачем нужны DTO (Data Transfer Objects)?
Ответ: DTO — объекты, которые переносят данные между слоями (например, фронтенд <-> бэкенд). Позволяют чётко определить структуру передаваемых данных, облегчить валидацию.

Вопрос: Что такое «observer pattern»?
Ответ: Паттерн «наблюдатель» — объект (subject) хранит список наблюдателей (observers) и при изменении состояния оповещает их, чтобы они могли реагировать (обновить UI или выполнить логику).

Вопрос: В чём разница между «композицией» и «наследованием»?
Ответ: Композиция (has-a) предполагает, что объект содержит другой объект для переиспользования функционала. Наследование (is-a) расширяет поведение предка. Композиция часто предпочтительнее из-за более слабой связности.

Вопрос: Чем отличаются «императивное» и «декларативное» программирование?
Ответ:

    Императивное — указываем «как» сделать (последовательность шагов).
    Декларативное — указываем «что» хотим получить, не вдаваясь в подробности реализации.

Вопрос: Что такое «PWA» (Progressive Web App)?
Ответ: Веб-приложение, обладающее рядом возможностей нативных приложений: офлайн-режим, push-уведомления, иконка на домашнем экране. Использует Service Worker, HTTPS, манифест.

Вопрос: Зачем нужен «Feature Toggle» (или Feature Flag)?
Ответ: Позволяет включать/отключать функционал в приложении без деплоя новой версии. Удобно для A/B-тестов, постепенного раската фич, быстрого отката.

Вопрос: В чем разница между «Monorepo» и «Polyrepo» подходами?
Ответ:

    Monorepo: все модули/проекты хранятся в одном репозитории, упрощается совместная разработка, общее версионирование.
    Polyrepo: каждый проект в своём репозитории, более независимый цикл релизов, но сложнее управлять межпроектными зависимостями.

Вопрос: Что такое «Command Query Responsibility Segregation» (CQRS)?
Ответ: Разделение на операции чтения (Query) и записи (Command) над данными. Часто используется для повышения масштабируемости, упрощения логики. На фронтенде иногда встречается в больших проектах.

Вопрос: Как планировать архитектуру фронтенда под будущее масштабирование?
Ответ: Разделять логику по фичам/модулям, использовать понятные паттерны, контролировать зависимости (не допускать «спагетти»). Возможно задействовать micro frontends, гибкие стейт-менеджеры.

Вопрос: Зачем нужен «Adapter pattern» во фронтенде?
Ответ: Адаптер превращает один интерфейс в другой, удобный для использования внутри приложения. Например, можно обернуть ответ API во внутреннюю структуру данных, чтобы компоненты не зависели от «сырого» формата.

Вопрос: Чем хорош паттерн «Dependency Injection»?
Ответ: Убирает жёсткие зависимости — объекты не создают напрямую другие объекты, а получают их «снаружи». Это улучшает тестируемость, гибкость, позволяет легко подменять реализации.

</details>

<details>
  <summary>Блок 5. Тестирование</summary>

Вопрос: Зачем нужны юнит-тесты?
Ответ: Юнит-тесты проверяют работу маленьких участков кода (функции, модули) в изоляции. Помогают быстро выявлять регрессии, повышают уверенность при рефакторинге.

Вопрос: Что такое «интеграционные тесты»?
Ответ: Проверяют, как несколько модулей работают вместе (функции, компоненты). Выявляют проблемы во взаимодействии между частями системы.

Вопрос: Что такое «E2E-тесты» (end-to-end)?
Ответ: Тестируют приложение целиком: пользовательские сценарии, взаимодействие фронтенда с бэкендом, поведение UI. Имитируют реальную работу пользователя, часто в браузере (Cypress, Playwright).

Вопрос: Что такое «mock» и «stub» в тестировании?
Ответ:

    Mock — объект-заглушка, которая имитирует поведение реального компонента/сервиса и позволяет проверять, как он был вызван.
    Stub — примитивная заглушка, которая возвращает зашитые значения, не всегда проверяет, как она используется.

Вопрос: В чем разница между TDD (Test-Driven Development) и BDD (Behavior-Driven Development)?
Ответ:

    TDD: сначала пишутся failing-тесты, затем код, удовлетворя тестам.
    BDD: упор на описание поведения, «user stories», понятный язык (Given-When-Then). Тесты пишутся более человеческим языком, близким к бизнес-требованиям.

Вопрос: Как тестировать асинхронный код?
Ответ: Использовать async/await в тестах, или колбэки done(), или промисы (.then/.catch). В Jest, например:

    test('fetch data', async () => {
        const data = await fetchData();
        expect(data).toBeDefined();
    });

Вопрос: Что такое «coverage» (покрытие тестами)?
Ответ: Показатель того, сколько строк/ветвей кода было выполнено во время тестов. Не является абсолютным критерием качества, но помогает найти «слепые зоны».

Вопрос: Зачем нужны snapshot-тесты (например, в React)?
Ответ: Сохраняют «снимок» рендера компонента (или выходных данных). При изменении кода сравнивают текущий результат со снимком, помогая обнаружить неожиданные изменения в UI.

Вопрос: Как тестировать верстку и стили?
Ответ: Полноценное юнит-тестирование CSS затруднительно. Можно использовать визуальные регрессионные тесты (скриншоты), интеграционные тесты, Storybook-подход.

Вопрос: Как организовать тестирование в CI/CD?
Ответ: В pipeline (например, GitHub Actions, GitLab CI, Jenkins) прописывают шаги: установка зависимостей, запуск линтеров, юнит-тесты, интеграционные/E2E-тесты. При неудаче билд прекращается.

</details>

<details>
  <summary>Блок 6. Безопасность</summary>

Вопрос: Что такое «XSS» (Cross-Site Scripting)?
Ответ: Уязвимость, когда злоумышленник внедряет вредоносный JS (через поля ввода, комментарии и т.д.), который затем выполняется у других пользователей.

Вопрос: Как защититься от XSS?
Ответ: Экранировать ввод (sanitize), использовать innerText/textContent вместо innerHTML, применять шаблонные движки с экранированием, выставлять Content Security Policy (CSP).

Вопрос: Что такое «CSRF» (Cross-Site Request Forgery)?
Ответ: Атака, когда пользователь, будучи авторизован, выполняет нежелательный запрос к сайту через поддельную форму/скрипт на другом сайте. Сервер видит, что куки пользователя валидны, и выполняет действие.

Вопрос: Как защититься от CSRF?
Ответ: Использовать CSRF-токены, SameSite cookies, проверять заголовок Origin/Referer. Хранить важные токены не в Local Storage, а в HttpOnly куки (если это подходит под архитектуру).

Вопрос: Что такое «clickjacking» и как защититься?
Ответ: Атака, когда сайт оборачивают в iframe, обманывая пользователя, чтобы он кликал по невидимым кнопкам. Защита: заголовки X-Frame-Options: DENY или Content-Security-Policy: frame-ancestors 'none';.

Вопрос: Что такое «HTTPS» и почему важно использовать?
Ответ: Протокол, шифрующий трафик между клиентом и сервером (TLS/SSL). Защищает от перехвата данных, подмены, MITM-атак.

Вопрос: Что такое «CORS» (Cross-Origin Resource Sharing)?
Ответ: Механизм, позволяющий браузеру ограничивать или разрешать запросы из одного домена к ресурсам другого домена. Управляется заголовками сервера (Access-Control-Allow-Origin, и т.д.).

Вопрос: В чем разница между «HttpOnly cookie» и обычной cookie?
Ответ: HttpOnly недоступна JS-коду (document.cookie), передается только при HTTP-запросах. Это усложняет кражу куки через XSS.

Вопрос: Что такое «JWT» (JSON Web Token)?
Ответ: Формат для передачи данных (обычно для авторизации). Состоит из заголовка, payload и подписи. Подпись позволяет удостовериться, что токен не изменен.

Вопрос: Как работать с JWT на фронтенде?
Ответ: Можно хранить токен в HttpOnly cookie или в Local Storage. При запросах отправлять токен в заголовке Authorization: Bearer .... Важно учитывать риски XSS/CSRF, настроить CORS, корректно обрабатывать ошибки истечения токена.

</details>

<details>
  <summary>Блок 7. Оптимизация и производительность</summary>

Вопрос: Что такое «Render Tree» в браузере?
Ответ: Внутреннее представление DOM + стили, которые будут влиять на то, как элемент будет выглядеть. Потом это дерево раскладывается (layout), и уже отрисовывается (paint).

Вопрос: Что такое «Reflow» и «Repaint»?
Ответ:

    Reflow (Layout) — перерасчет позиций и размеров элементов при изменении DOM/стилей.
    Repaint — перерисовка элементов, если изменился только цвет или фон.

Вопрос: Как минимизировать reflow/repaint?
Ответ: Группировать изменения DOM (например, использовать documentFragment или batch-обновления), избегать частого чтения/записи layout-свойств (offsetHeight и т.п.), анимировать transform и opacity.

Вопрос: Что такое «webpack» и зачем он нужен?
Ответ: Bundler, который собирает модули (JS, CSS, изображения) в единый или несколько выходных файлов, учитывая зависимости. Также умеет минифицировать, «трясти дерево» (tree shaking), динамически загружать код.

Вопрос: Что такое «Tree Shaking»?
Ответ: Удаление неиспользуемых экспортов/импортов в процессе сборки, чтобы уменьшить конечный бандл. Работает только с ESM (ES6 модулями), где возможен статический анализ.

Вопрос: Что такое «код-сплиттинг» (Code Splitting)?
Ответ: Разделение кода на части (чанки), которые загружаются по мере необходимости. Уменьшает время начальной загрузки, ускоряет отображение страницы.

Вопрос: Как работать с большими изображениями и не замедлять страницу?
Ответ: Сжимать (JPEG, WebP, AVIF), использовать responsive images (srcset), lazy loading, CDN. Ограничивать загрузку исходников сверхнужного разрешения.

Вопрос: Что такое lazy loading (ленивая загрузка)?
Ответ: Отложенная подгрузка ресурса (например, компонента, изображения) до тех пор, пока он не понадобится (попадёт в зону видимости). Экономит трафик и ускоряет загрузку главной страницы.

Вопрос: Какие главные метрики Web Vitals (Core Web Vitals) вы знаете?
Ответ:

    LCP (Largest Contentful Paint)
    FID (First Input Delay)
    CLS (Cumulative Layout Shift)
Они показывают, как быстро появляется главный контент, как быстро страница реагирует на действия и как сильно сдвигается макет.

Вопрос: Как загрузить CSS или JS асинхронно?
Ответ:

Для JS: атрибуты async или defer.
Для CSS: <link rel="preload" as="style" href="..." onload="this.rel='stylesheet'">, либо использовать динамическую вставку <link> через JS.
Вопрос: Что такое «HTTP/2» и чем оно лучше HTTP/1.1?
Ответ: Поддерживает мультиплексирование (несколько запросов в одном TCP-соединении), сервер push (не всегда актуальный), бинарный протокол. Ускоряет загрузку ресурсов.

Вопрос: Как проверить реальную производительность сайта?
Ответ: Использовать Chrome DevTools (Performance), Lighthouse, WebPageTest, проводить тесты на реальном устройстве (мобильном), анализировать скорость отображения ключевых элементов.

Вопрос: Зачем нужна минификация CSS и JS?
Ответ: Уменьшает размер файлов, удаляет пробелы, комментарии, сокращает имена переменных. Сокращает трафик и ускоряет загрузку.

Вопрос: Как оптимизировать критический путь рендеринга (Critical Rendering Path)?
Ответ: Уменьшить количество блокирующих запросов (CSS, JS), использовать inlined critical CSS, откладывать тяжёлый JS, обеспечивать раннюю загрузку ключевых ресурсов.

Вопрос: Что такое «preconnect», «dns-prefetch», «prefetch»?
Ответ: Методы <link>-оптимизации:

dns-prefetch — заранее резолвит DNS-домен.
preconnect — заранее устанавливает TCP/TLS-соединение с хостом.
prefetch — загружает ресурс в фоновом режиме, когда браузер свободен, для будущих переходов.
Вопрос: Как уменьшить «blocking time» при загрузке страницы?
Ответ: Разделить большой JS на чанки, загружать не критичный код лениво, выносить тяжелые вычисления из главного потока (Web Workers), минифицировать/оптимизировать зависимости.

Вопрос: Что такое «HTTP caching» (etag, last-modified)?
Ответ: Механизм, где браузер хранит копию ресурса и при повторных запросах проверяет его актуальность. ETag (уникальный хэш файла) и Last-Modified позволяют понять, изменился ли ресурс.

Вопрос: Что такое «Critical CSS»?
Ответ: Выделение стилей, необходимых для отображения верхней части страницы (above-the-fold), и инлайн-вставка их в <head>. Остальной CSS можно загрузить позже.

Вопрос: Чем отличаются «setTimeout(fn, 0)» и «requestAnimationFrame(fn)»?
Ответ:

setTimeout(fn,0) ставит колбэк в очередь macrotask. Выполнится после текущего стека.
requestAnimationFrame(fn) оптимизируется под перерисовку, колбэк вызывается перед следующим перерисовыванием браузера.
Вопрос: Что такое «Debounce» и «Throttle»?
Ответ:

Debounce — запуск функции после того, как событие перестало «триггериться» определённое время.
Throttle — ограничивает частоту вызова функции, не позволяя вызываться чаще заданного интервала.

</details>

<details>
  <summary>Блок 8. Версионность и CI/CD</summary>

Вопрос: Зачем нужен контроль версий (Git) в проектах?
Ответ: Позволяет отслеживать изменения в коде, работать в команде, откатываться к предыдущим состояниям, параллельно вести несколько веток разработки.

Вопрос: Какие распространённые ветвления (branching) для Git вы знаете?
Ответ:
- Git Flow (master, develop, feature, release, hotfix).
- GitHub Flow (main + feature-branches).
- GitLab Flow (подобно GitHub Flow, но могут быть «environments branches»).

Вопрос: Чем отличается merge от rebase?
Ответ:
- merge: слияние ветки создает дополнительный merge-коммит, сохраняет историю ветвления.
- rebase: «переигрывает» коммиты на новой базе, делая историю линейной, без merge-коммитов.

Вопрос: Что такое «Pull Request» (или Merge Request)?
Ответ: Запрос на вливание изменений из одной ветки в другую, где участники могут просмотреть код, обсудить и произвести код-ревью перед слиянием.

Вопрос: Как организовать «code review» и почему это важно?
Ответ: Code review — проверка кода коллегами, поиск ошибок, улучшение архитектуры, обмен знаниями. Обычно делается через Pull Requests, оставляются комментарии, приёмка только после правок.

Вопрос: Что такое «continuous integration» (CI)?
Ответ: Практика, где каждая интеграция кода (commit/merge) автоматически проверяется сборкой и тестами. Помогает быстро находить ошибки, сохранять код в рабочем состоянии.

Вопрос: Что такое «continuous delivery» (CD)?
Ответ: Автоматический процесс, который после успешного прохождения CI может выкатывать изменения на «staging» или продакшен, часто с ручной «кнопкой» одобрения.

Вопрос: Зачем использовать «Git hooks» (pre-commit, pre-push)?
Ответ: Автоматизировать задачи перед коммитом или пушем (запуск линтеров, тестов). Это помогает удерживать качество кода и не отправлять «сломанные» изменения в репозиторий.

Вопрос: Что такое «semantic versioning» (semver)?
Ответ: Схема версионирования MAJOR.MINOR.PATCH:
- MAJOR — несовместимые изменения.
- MINOR — новая функциональность, сохраняющая обратную совместимость.
- PATCH — багфиксы без новых фич.

Вопрос: Что такое «release branch»?
Ответ: В Git Flow это ветка, предназначенная для подготовки релиза (тестирование, фиксы). После успешной проверки она вливается в основную ветку (master/main).

Вопрос: Как автоматизировать деплой фронтенд-приложения?
Ответ: С помощью CI/CD (GitHub Actions, GitLab, Jenkins). Шаги: установка зависимостей, сборка, тесты, деплой на сервер/облако. При удачном сценарии приложение обновляется автоматически.

Вопрос: Что такое «artifact» в контексте CI?
Ответ: Скомпилированные файлы (например, папка build), отчеты о тестах, логи — всё, что генерируется в процессе сборки/тестов и может быть сохранено или передано на следующий этап.

Вопрос: Что делать, если сборка упала на тестах или линтинге?
Ответ: Исправить ошибки, указанные в логах, сделать новый commit. CI автоматически перезапустит сборку. Важно отслеживать, чтобы main-ветка оставалась «зелёной».

Вопрос: Что такое «feature environment» (или review apps)?
Ответ: Отдельное окружение (стенд), куда автоматически деплоится код из feature-ветки. Позволяет протестировать/показать функционал без влияния на основной стенд.

Вопрос: Чем полезны Docker и контейнеризация для фронтенда?
Ответ: Гарантированное окружение сборки и запуска, независимое от локальных настроек. Упрощает CI/CD, позволяет легко разворачивать приложение, масштабировать.

Вопрос: Как в Dockerfile собирать фронтенд-приложение?
Ответ: Чаще используют Multi-stage build:
1) Базовый образ с Node, установка зависимостей, сборка npm run build.
2) Минимальный образ (например, Nginx), копирование собранных статических файлов, запуск Nginx.

Вопрос: Что такое «Blue-Green Deployment» и «Canary Release»?
Ответ:
- Blue-Green: две одинаковые среды (Blue и Green). Новая версия деплоится в Green, а затем трафик переключается с Blue на Green, исключая простой.
- Canary: выкатываем новую версию на небольшую часть пользователей, проверяем, потом постепенно расширяем.

Вопрос: Когда нужно использовать «Git submodules» или «monorepo tools» (Lerna, Nx)?
Ответ: Если проект состоит из нескольких связанных пакетов (библиотек, компонентов). Monorepo-tools дают больше удобства, чем submodules. Submodules подходят, когда репозитории действительно независимы, но иногда осложняют dev-процесс.

Вопрос: Что такое «artifact repository» (например, Nexus, Artifactory)?
Ответ: Хранилище скомпилированных артефактов (npm-пакеты, jar-файлы и т.п.). Удобно для больших команд, чтобы локально сохранять зависимости, бинарники.

Вопрос: Как происходит «Rollbacks» (откат релиза)?
Ответ: Либо переключение трафика обратно (Blue-Green), либо откат до предыдущего билда (в Git CI/CD можно «revert» или хранить предыдущий образ Docker). Важно иметь четкую стратегию быстрого отката на случай критических багов.

</details>

<details>
  <summary>Блок 9. Разработка и команды</summary>

Вопрос: Что такое agile-методологии (Scrum, Kanban)?
Ответ: Гибкие методологии разработки:
- Scrum: спринты, ежедневные встречи, планирование, ретроспектива.
- Kanban: визуализация задач на доске, ограничение WIP, непрерывный поток.
  Цель — быстро реагировать на изменения, доставлять ценность.

Вопрос: Что такое «backlog»?
Ответ: Список (очередь) задач, требований, идей, упорядоченный по приоритету. В Scrum команды работают со спринтовым backlog (на текущий спринт) и product backlog (общий список).

Вопрос: Для чего нужны «user stories»?
Ответ: Короткие описания функционала с точки зрения пользователя. Формат «Я, как [роль], хочу [действие], чтобы [ценность]». Помогает фокусироваться на реальных потребностях клиента.

Вопрос: Что такое «story points» и как они связаны с «estimation»?
Ответ: Единица измерения сложности задачи (не привязана напрямую к часам). Команда оценивает задачи в story points, учитывая сложность, риски, объем. Это помогает планировать спринты.

Вопрос: Что делать, если задача сильно «выползает» за отведенное время?
Ответ: Нужно переоценить задачи, поднять вопрос на daily/retro, возможно разбить задачу на меньшие подзадачи, устранить блокеры или переорганизовать приоритеты.

Вопрос: Как проводить «дему» (демонстрацию) по завершении спринта?
Ответ: Показывать команде и стейкхолдерам, что было сделано за спринт, как решены задачи, в каком виде это работает. Цель — получить обратную связь и признание выполненных задач.

Вопрос: Что такое «ретроспектива» (retrospective)?
Ответ: В Scrum встреча, где команда анализирует прошедший спринт, выявляет, что было хорошо/плохо, и согласовывает, что можно улучшить в будущем (процессы, коммуникации, инструменты).

Вопрос: Какие основные практики помогают поддерживать качество кода?
Ответ: Код-ревью, тесты, линтеры, форматтеры, CI, рефакторинг, парное программирование, ротация задач, четкий гайдлайн по стилю кода.

Вопрос: Зачем нужен «технический долг» (technical debt) и как с ним бороться?
Ответ: Техдолг — это результат компромиссов, неряшливого кода, краткосрочных решений. Борьба: рефакторинги, выделение времени в спринтах, регламент код-ревью, стандарты.

Вопрос: Почему важно документировать API, архитектуру, компоненты?
Ответ: Для поддерживаемости: новые разработчики быстрее вникают, меньше риск неправильного использования. Документация уменьшает «bus factor» и повышает прозрачность проекта.

</details>

<details>
  <summary>Блок 10. Дополнительные темы, широкий кругозор</summary>

Вопрос: Что такое «REST» и чем отличается от «SOAP»?
Ответ:
- REST — стиль архитектуры HTTP-API: ресурсы, методы, коды ответа. Легковесный, чаще используется в вебе.
- SOAP — протокол обмена сообщениями на основе XML, более формальный и тяжелый, реже на фронтенде.

Вопрос: Зачем нужен «GraphQL»?
Ответ: Позволяет клиенту запрашивать только нужные поля, избегая overfetching/underfetching. Имеет схему (type system), упрощает эволюцию API. Но требует настроить сервер GraphQL.

Вопрос: Что такое «WebSocket»?
Ответ: Протокол для постоянного двунаправленного соединения между клиентом и сервером. Используется для чатов, онлайн-игр, где важен реальный тайм.

Вопрос: Чем «SSE» (Server-Sent Events) отличается от WebSocket?
Ответ: SSE — односторонний канал от сервера к клиенту (только события от сервера). WebSocket — двунаправленный, клиент и сервер могут отправлять данные в любой момент.

Вопрос: Что такое «Puppeteer» или «Playwright»?
Ответ: Библиотеки для управления браузером (Chrome, Edge, Firefox). Позволяют делать скриншоты, автоматизировать тесты, парсить страницы. Широко применяются для E2E-тестов, генерации PDF, веб-скрейпинга.

Вопрос: Какие существуют способы хранения данных на клиенте?
Ответ: Cookies, Local Storage, Session Storage, IndexedDB, WebSQL (устаревшее), Cache Storage (для PWA). Выбор зависит от объема данных и требований безопасности.

Вопрос: Что такое «hybrid apps» (Cordova, Ionic, Capacitor)?
Ответ: Приложения, где веб-приложение «завёрнуто» в нативную оболочку. Можно публиковать в App Store/Google Play. Гибрид между нативной разработкой и чистым вебом.

Вопрос: Чем полезен «React Native», «Flutter» или «NativeScript»?
Ответ: Позволяют разрабатывать мобильные приложения с использованием языков и инструментов, близких к веб-разработке (JS, Dart), при этом получая результат близкий к нативному.

Вопрос: Что такое «Web Components»?
Ответ: Нативный стандарт (Custom Elements, Shadow DOM, HTML Templates) для создания инкапсулированных UI-компонентов без привязки к конкретному фреймворку. Могут использоваться в разных приложениях.

Вопрос: Для чего нужна «GraphQL Subscriptions»?
Ответ: Подписки (subscriptions) в GraphQL позволяют получать данные в реальном времени (обычно поверх WebSocket). Сервер пушит обновления клиенту по событию (например, добавление комментария).

Вопрос: Как работать с датами и временем в JS без ошибок?
Ответ: Использовать библиотеки (date-fns, dayjs, Luxon) или встроенный Intl.DateTimeFormat. Учитывать временные зоны (UTC vs local), ISO-строки. JS Date достаточно путанный в использовании.

Вопрос: Что такое «полнотекстовый поиск» и есть ли ему применение на фронтенде?
Ответ: Полнотекстовый поиск обычно организуется на серверной стороне (ElasticSearch, Lucene). На фронте можно иметь упрощённую реализацию (Lunr, Fuse.js) для поиска по локальному набору данных.

Вопрос: Чем отличается «юнит-тест» логики и «визуальный тест» компонентов (visual regression)?
Ответ: Юнит-тест проверяет правильность алгоритмов, данных. Визуальный тест сравнивает скриншоты или DOM-структуру, чтобы выявить непреднамеренные изменения во внешнем виде/разметке.

Вопрос: Что такое «Internationalization (i18n)» и «Localization (l10n)»?
Ответ:
- i18n — подготовка приложения к поддержке нескольких языков (переводы, форматы дат/чисел, валюты).
- l10n — конкретный процесс перевода, подстройки под культуру (единицы измерения, правила множественности).

Вопрос: Какие преимущества даёт «server-side rendering» (SSR)?
Ответ: Быстрый первый рендер (HTML уже готов на сервере), лучшее SEO (поисковики сразу видят готовый контент), меньше проблем с динамическим индексированием. Но усложняет архитектуру.

Вопрос: Что такое «static site generation» (SSG)?
Ответ: Генерация HTML на этапе сборки (build time). Страницы отдаются как статические файлы, очень быстрые при доставке, но менее гибкие, чем полноценный SSR.

Вопрос: Как реализуется «офлайн-режим» в веб-приложениях?
Ответ: Через Service Worker (кэширование ресурсов), IndexedDB для хранения данных. При отсутствии сети можно работать с локальными данными и синхронизировать при возврате в онлайн.

Вопрос: Что такое «push-уведомления» в браузере?
Ответ: Механизм, где сервис-воркер может получать push-сообщения от сервера даже при закрытой вкладке, и показывать нативные уведомления. Требуется HTTPS, разрешение пользователя.

Вопрос: Что означает «доступность» (accessibility, A11y)?
Ответ: Возможность пользоваться веб-сайтом людям с ограниченными возможностями (скринридеры, клавиатурная навигация, контраст, адаптация под вспомогательные технологии).

Вопрос: Как проверить доступность страницы?
Ответ: Инструменты (Lighthouse, axe, WAVE), ручной тест с клавиатуры, использование экранных читалок (NVDA, VoiceOver), проверка контрастности и семантической структуры.

Вопрос: Что делать, если проект очень старый (legacy) и код сложно менять?
Ответ: Постепенно рефакторить, покрывать тестами критичные части, выделять техническую задолженность в отдельные задачи, внедрять линтеры/форматтеры поэтапно.

Вопрос: Что такое «метрики ошибок» (Sentry, Rollbar) и зачем их собирать?
Ответ: Сервисы для сбора runtime-ошибок в продакшене. Позволяют видеть stack trace, окружение пользователя, процент затронутых пользователей. Это помогает оперативно чинить баги.

Вопрос: Как работать с «MSW» (Mock Service Worker)?
Ответ: Инструмент для подмены/мокирования сетевых запросов на клиенте. Полезен при тестировании или локальной разработке, когда нет реального бэкенда или нужно «зафиксировать» ответы.

Вопрос: В чем смысл «типизации» (TypeScript, Flow) для фронтенда?
Ответ: Статическая проверка типов снижает количество ошибок, улучшает автодополнение (intellisense), делает код более надёжным и удобным в поддержке.

Вопрос: Чем отличается «mutable» и «immutable» объект?
Ответ: mutable можно менять напрямую (obj.prop = newVal), а immutable после создания остаётся неизменным (вместо редактирования — создаём новую копию с нужными изменениями).

Вопрос: Что такое «принцип единой ответственности» (Single Responsibility Principle)?
Ответ: Каждый модуль/функция/компонент должен отвечать только за одну задачу или аспект функциональности. Упрощает понимание, тестирование, переиспользование.

Вопрос: Что такое «композиция функций» (function composition)?
Ответ: Связывание выходного значения одной функции со входом другой. Например, compose(f, g)(x) = f(g(x)). Помогает писать более декларативный и модульный код.

Вопрос: Как проводить интервью с кандидатами на фронтенд-разработку?
Ответ: Проверять фундаментальные знания (HTML/CSS/JS), опыт с инструментами и фреймворками, навыки архитектурного мышления, умение решать задачи, коммуникацию. Задавать вопросы, давать тестовые.

Вопрос: В чём смысл «soft skills» для разработчика?
Ответ: Умение общаться, работать в команде, объяснять идеи, брать ответственность, принимать критику, планировать задачи. Разработчик с хорошими soft skills эффективнее в коллективной работе.

Вопрос: Что делать, если в команде возник конфликт (например, по архитектуре)?
Ответ: Проводить открытое обсуждение, оценивать варианты, аргументировать. При необходимости привлечь тимлида/архитектора/PM, прийти к консенсусу или компромиссу.

Вопрос: Как поддерживать работу приложения в IE11 или других устаревших браузерах?
Ответ: Использовать полифилы (core-js, regenerator), транспиляцию (Babel), иногда «graceful degradation» или «progressive enhancement». Оценивать, насколько это действительно нужно бизнесу.

Вопрос: Как использовать «performance profiling» в браузерных DevTools?
Ответ: Открыть вкладку Performance, начать запись, воспроизвести действия. Анализировать диаграмму: где много JS, reflow, garbage collection и т.д. Оптимизировать проблемные места.

Вопрос: Что такое «Scroll hijacking» и почему это плохо?
Ответ: Когда разработчик переопределяет поведение скролла (например, с помощью анимаций или задержек). Может ухудшить UX, ломает привычную прокрутку, вызывает дискомфорт.

Вопрос: Какие есть альтернативы Redux для управления состоянием?
Ответ: MobX, Zustand, Recoil, Context API, Vuex (в Vue), Pinia (Vue), NGXS (Angular). Выбор зависит от фреймворка и предпочтений команды.

Вопрос: Зачем использовать «Docker Compose»?
Ответ: Для определения и запуска многоконтейнерных приложений (например, фронтенд + бэкенд + БД) одной командой. Удобно для локальной разработки и тестирования.

Вопрос: Что такое «SSR security considerations»? (в контексте next.js, nuxt.js)
Ответ: Безопасность при серверном рендеринге: защита от XSS при генерации HTML (экранирование), проверка пользовательских данных, авторизация на сервере, корректная работа с куки.

Вопрос: Чем отличается «native event» от «synthetic event» (например, в React)?
Ответ: Synthetic event — обертка над нативным событием, которую фреймворк использует для кроссбраузерной совместимости и дополнительной логики. Но содержит nativeEvent внутри, если нужно обращаться к реальному событию.

Вопрос: Что такое «версионирование API»?
Ответ: Когда меняется формат запроса/ответа, можно выпускать новую версию API (v1, v2), чтобы не ломать старые клиенты. Фронтенд выбирает нужную версию эндпоинта.

Вопрос: Зачем нужны «хэши» (hash) в названиях сборки (например, main.abc123.js)?
Ответ: Для кэширования браузером. Если файл меняется — хэш меняется, браузер загружает новый файл, иначе хранит в кеше. Это называется cache busting.

Вопрос: Что такое «Source Maps» и как они помогают?
Ответ: Файлы, которые «сопоставляют» минифицированный/скомпилированный код с исходным. Позволяют удобно отлаживать в браузере, видя исходные строчки.

Вопрос: Как работать с «private npm registry» (Nexus, Verdaccio)?
Ответ: Настраивать в .npmrc URL приватного репозитория. Можно публиковать внутренние пакеты, общие библиотеки, не выкладывая их в публичный registry.

Вопрос: Что такое «feature branches» и зачем они нужны?
Ответ: Отдельные ветки на каждую задачу/фичу. Разработчик изолированно работает над функционалом. После завершения создаётся Pull Request для вливания в основную ветку.

Вопрос: Как поступать с «merge conflicts»?
Ответ: Разрешать конфликты вручную, выбирая нужные изменения или объединяя их. Полезно общаться с коллегами, если конфликт сложный или затрагивает разные части кода.

Вопрос: Что значит «инкубационный период» или «фичи в бете»?
Ответ: Фичи в стадии тестирования, могут быть не полностью стабильны. Включаются ограниченному кругу пользователей (бета-тестирование). Если всё хорошо, переносятся в продакшен.

Вопрос: Как проводить UX-тестирование (usability testing)?
Ответ: Приглашать реальных или потенциальных пользователей, давать им задания, наблюдать за взаимодействием с интерфейсом, собирать фидбэк. Могут использовать прототипы, макеты, реальное приложение.

Вопрос: Что такое «micro frontends»?
Ответ: Архитектура, когда большое веб-приложение разбивается на независимые модули (фронтенды), каждый со своим жизненным циклом, деплоем, командой. Позволяет масштабировать разработку, но усложняет интеграцию.

Вопрос: Для чего нужен «Storybook»?
Ответ: Инструмент для изолированной разработки и документации UI-компонентов. Позволяет видеть компоненты в разных состояниях, проверять их независимо от всей аппликации.

Вопрос: Что такое «HMR» (Hot Module Replacement)?
Ответ: Функция сборщиков (например, Webpack) для «горячей» замены модулей (CSS/JS) в браузере без полной перезагрузки страницы, сохраняя состояние приложения. Ускоряет разработку.

Вопрос: Как внедрить ESLint/Prettier в проект?
Ответ: Установить ESLint и/или Prettier, настроить .eslintrc, .prettierrc. Добавить скрипты в package.json ("lint": "eslint ."). Для автоматизации — Git hooks (husky) или CI, чтобы код не попадал неформатированным.

Вопрос: Что важнее для Middle/Middle+ специалиста: глубина в одном фреймворке или широкая база знаний?
Ответ: Нужно сочетание. Глубокие знания ключевых технологий и архитектурных паттернов + умение быстро адаптироваться к новому. Широкий кругозор помогает принимать взвешенные решения, а глубина обеспечивает качество реализации.

</details>
